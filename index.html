<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8" />
    <title>SkyRunner 3D - Dokunmatik Uçak Oyunu</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* HUD */
        .hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .hud-top-left {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            font-size: 11px;
            max-width: 250px;
            backdrop-filter: blur(6px);
        }

        .hud-top-left h1 {
            font-size: 14px;
            margin-bottom: 4px;
        }

        .hud-top-left p {
            opacity: 0.85;
            line-height: 1.4;
        }

        .hud-top-center {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            font-size: 11px;
            backdrop-filter: blur(6px);
        }

        .hud-chip {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .hud-label {
            font-size: 10px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .hud-value {
            font-size: 13px;
            font-weight: 600;
        }

        .hud-bottom-center {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.4);
            color: #fff;
            font-size: 11px;
            backdrop-filter: blur(6px);
        }

        /* Dokunmatik Kontroller */
        .touch-controls {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .pad-left,
        .pad-right {
            position: absolute;
            bottom: 12px;
            width: 45%;
            max-width: 260px;
            height: 40%;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 10px;
            pointer-events: auto;
        }

        .pad-left {
            left: 6px;
        }

        .pad-right {
            right: 6px;
        }

        .ctrl-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .ctrl-row {
            display: flex;
            justify-content: center;
            gap: 6px;
        }

        .ctrl-btn {
            width: 54px;
            height: 54px;
            border-radius: 50%;
            border: none;
            background: radial-gradient(circle at 30% 30%, #ffffff, #c0c0c0);
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.6);
            font-size: 20px;
            font-weight: 700;
            color: #333;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        .ctrl-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 rgba(0, 0, 0, 0.7);
        }

        .ctrl-btn.small {
            width: 44px;
            height: 44px;
            font-size: 18px;
        }

        .ctrl-label {
            text-align: center;
            color: #fff;
            font-size: 10px;
            margin-top: 2px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.9);
        }

        /* Orta nişangâh */
        .reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.75);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            pointer-events: none;
        }

        .reticle::before,
        .reticle::after {
            content: "";
            position: absolute;
            background: rgba(255,255,255,0.7);
        }

        .reticle::before {
            width: 120%;
            height: 1px;
            top: 50%;
            left: -10%;
        }

        .reticle::after {
            width: 1px;
            height: 120%;
            left: 50%;
            top: -10%;
        }

        /* Başlangıç mesajı */
        .center-message {
            position: absolute;
            top: 22%;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 16px;
            border-radius: 14px;
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            text-align: center;
            font-size: 12px;
            max-width: 320px;
            pointer-events: none;
            backdrop-filter: blur(6px);
        }

        .center-message-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .center-message-sub {
            opacity: 0.9;
        }

        .fade-out {
            animation: fadeOut 0.7s forwards;
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to   { opacity: 0; visibility: hidden; }
        }

        /* Game over etiketi */
        .game-over-banner {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 16px;
            border-radius: 10px;
            background: rgba(120, 0, 0, 0.8);
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            pointer-events: none;
            display: none;
        }

        .game-over-banner span {
            display: block;
            font-size: 11px;
            font-weight: 400;
            margin-top: 4px;
            opacity: 0.9;
        }

        @media (min-width: 900px) {
            .hud-top-left { font-size: 12px; }
            .hud-top-center { font-size: 12px; }
            .hud-value { font-size: 14px; }
        }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="hud">
        <div class="hud-top-left">
            <h1>SkyRunner 3D</h1>
            <p>
                Dokunmatik: Sol pad ile <strong>yön</strong>, sağ pad ile <strong>irtifa</strong> ve <strong>gaz</strong> kontrol.<br/>
                Klavye: W/S (gaz), A/D (yaw), ok tuşları (pitch).<br/>
                R: Reset · Uçak yere çarparsa oyun biter.
            </p>
        </div>

        <div class="hud-top-center">
            <div class="hud-chip">
                <div class="hud-label">Hız (kn)</div>
                <div class="hud-value" id="hudSpeed">0</div>
            </div>
            <div class="hud-chip">
                <div class="hud-label">Yükseklik (m)</div>
                <div class="hud-value" id="hudAlt">0</div>
            </div>
            <div class="hud-chip">
                <div class="hud-label">Mesafe (km)</div>
                <div class="hud-value" id="hudDist">0.0</div>
            </div>
            <div class="hud-chip">
                <div class="hud-label">Durum</div>
                <div class="hud-value" id="hudStatus">IDLE</div>
            </div>
        </div>

        <div class="hud-bottom-center">
            SkyRunner 3D · Basit fizik, 3D sahne ve dokunmatik kontroller.
        </div>

        <div class="reticle"></div>

        <div class="center-message" id="startMessage">
            <div class="center-message-title">Uçuşa Hazır ✈️</div>
            <div class="center-message-sub">
                Hız vermek için sağ alttaki <b>+</b> tuşuna dokun veya klavyeden <b>W</b> / <b>Yukarı Ok</b>'a bas.
            </div>
        </div>

        <div class="game-over-banner" id="gameOverBanner">
            CRASH! Uçak yere çarptı.
            <span>Yeniden başlatmak için R tuşuna bas veya sayfayı yenile.</span>
        </div>
    </div>

    <!-- Dokunmatik kontrol padleri -->
    <div class="touch-controls">
        <!-- Sol pad: yaw (sağ-sol) -->
        <div class="pad-left">
            <div class="ctrl-group">
                <div class="ctrl-row">
                    <button class="ctrl-btn" id="btnYawLeft">◀</button>
                    <button class="ctrl-btn" id="btnYawRight">▶</button>
                </div>
                <div class="ctrl-label">Yön (Yaw)</div>
            </div>
        </div>

        <!-- Sağ pad: pitch ve throttle -->
        <div class="pad-right">
            <div class="ctrl-group">
                <div class="ctrl-row">
                    <button class="ctrl-btn small" id="btnThrottleDown">–</button>
                    <button class="ctrl-btn small" id="btnThrottleUp">+</button>
                </div>
                <div class="ctrl-label">Gaz</div>
                <div class="ctrl-row">
                    <button class="ctrl-btn" id="btnPitchUp">▲</button>
                    <button class="ctrl-btn" id="btnPitchDown">▼</button>
                </div>
                <div class="ctrl-label">İrtifa (Pitch)</div>
            </div>
        </div>
    </div>
</div>

<!-- three.js CDN -->
<script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>

<script>
(function () {
    "use strict";

    const canvas = document.getElementById("gameCanvas");
    const hudSpeed = document.getElementById("hudSpeed");
    const hudAlt   = document.getElementById("hudAlt");
    const hudDist  = document.getElementById("hudDist");
    const hudStatus= document.getElementById("hudStatus");
    const startMessage = document.getElementById("startMessage");
    const gameOverBanner = document.getElementById("gameOverBanner");

    const btnYawLeft       = document.getElementById("btnYawLeft");
    const btnYawRight      = document.getElementById("btnYawRight");
    const btnPitchUp       = document.getElementById("btnPitchUp");
    const btnPitchDown     = document.getElementById("btnPitchDown");
    const btnThrottleUp    = document.getElementById("btnThrottleUp");
    const btnThrottleDown  = document.getElementById("btnThrottleDown");

    function resize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        if (camera) {
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height, false);
        }
    }
    window.addEventListener("resize", resize);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x88ccee, 50, 2000);

    const camera = new THREE.PerspectiveCamera(
        65,
        window.innerWidth / window.innerHeight,
        0.1,
        5000
    );

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    renderer.outputEncoding = THREE.sRGBEncoding;

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x406080, 0.9);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(50, 100, -20);
    scene.add(dirLight);

    // Sky gradient: basit bir büyük küre
    const skyGeo = new THREE.SphereGeometry(3000, 32, 24);
    const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
            topColor: { value: new THREE.Color(0x3a7bd5) },
            bottomColor: { value: new THREE.Color(0x050505) },
            offset: { value: 400 },
            exponent: { value: 0.6 }
        },
        vertexShader: `
            varying float vHeight;
            void main() {
                vHeight = position.y;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            varying float vHeight;
            void main() {
                float h = normalize(vec3(0.0, vHeight + offset, 0.0)).y;
                float t = max(pow(max(h, 0.0), exponent), 0.0);
                gl_FragColor = vec4(mix(bottomColor, topColor, t), 1.0);
            }
        `
    });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // Zemin
    const groundGeo = new THREE.PlaneGeometry(6000, 6000, 64, 64);
    const groundMat = new THREE.MeshStandardMaterial({
        color: 0x113322,
        roughness: 0.9,
        metalness: 0.0
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    // Pist
    const runwayGeo = new THREE.PlaneGeometry(400, 40);
    const runwayMat = new THREE.MeshStandardMaterial({
        color: 0x333333,
        roughness: 0.8
    });
    const runway = new THREE.Mesh(runwayGeo, runwayMat);
    runway.rotation.x = -Math.PI / 2;
    runway.position.set(0, 0.01, -200);
    scene.add(runway);

    // Pist çizgileri için basit mesh
    const stripeGeo = new THREE.PlaneGeometry(20, 2);
    const stripeMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    for (let i = 0; i < 8; i++) {
        const stripe = new THREE.Mesh(stripeGeo, stripeMat);
        stripe.rotation.x = -Math.PI / 2;
        stripe.position.set(0, 0.02, -200 + i * 20);
        scene.add(stripe);
    }

    // Basit binalar
    const cityGroup = new THREE.Group();
    const buildingGeo = new THREE.BoxGeometry(20, 40, 20);
    for (let i = 0; i < 40; i++) {
        const mat = new THREE.MeshStandardMaterial({
            color: new THREE.Color().setHSL(0.55 + Math.random() * 0.05, 0.5, 0.25 + Math.random() * 0.1),
            roughness: 0.9
        });
        const b = new THREE.Mesh(buildingGeo, mat);
        b.scale.y = 1 + Math.random() * 4;
        const side = Math.random() < 0.5 ? -1 : 1;
        const dist = 200 + Math.random() * 1500;
        const offsetX = side * (80 + Math.random() * 400);
        const offsetZ = dist + (Math.random() - 0.5) * 400;
        b.position.set(offsetX, (b.scale.y * 40) / 2, offsetZ);
        b.castShadow = true;
        b.receiveShadow = true;
        cityGroup.add(b);
    }
    scene.add(cityGroup);

    // Uçak
    const plane = new THREE.Group();
    const bodyGeo = new THREE.CylinderGeometry(2, 2, 20, 12);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xf5f6fa, metalness: 0.3, roughness: 0.4 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.rotation.z = Math.PI / 2;
    plane.add(body);

    const noseGeo = new THREE.ConeGeometry(2.2, 4, 12);
    const noseMat = new THREE.MeshStandardMaterial({ color: 0x3498db, metalness: 0.4, roughness: 0.3 });
    const nose = new THREE.Mesh(noseGeo, noseMat);
    nose.position.set(10, 0, 0);
    nose.rotation.z = Math.PI / 2;
    plane.add(nose);

    const wingGeo = new THREE.BoxGeometry(2, 18, 0.6);
    const wingMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6, roughness: 0.5 });
    const wingLeft = new THREE.Mesh(wingGeo, wingMat);
    wingLeft.position.set(0, 0, -7);
    plane.add(wingLeft);

    const wingRight = wingLeft.clone();
    wingRight.position.z = 7;
    plane.add(wingRight);

    const tailGeo = new THREE.BoxGeometry(2, 6, 0.4);
    const tail = new THREE.Mesh(tailGeo, wingMat);
    tail.position.set(-9, 2, 0);
    tail.rotation.z = Math.PI / 12;
    plane.add(tail);

    const tailHGeo = new THREE.BoxGeometry(1.2, 5, 0.3);
    const tailHLeft = new THREE.Mesh(tailHGeo, wingMat);
    tailHLeft.position.set(-8, 0, -3);
    plane.add(tailHLeft);
    const tailHRight = tailHLeft.clone();
    tailHRight.position.z = 3;
    plane.add(tailHRight);

    plane.position.set(0, 4, 0);
    plane.rotation.set(0, 0, 0);
    scene.add(plane);

    camera.position.set(-20, 10, 40);
    camera.lookAt(plane.position);

    // Girdiler
    const keys = {};
    const input = {
        yawLeft: false,
        yawRight: false,
        pitchUp: false,
        pitchDown: false,
        throttleUp: false,
        throttleDown: false
    };

    window.addEventListener("keydown", e => {
        keys[e.key] = true;
        if (e.key === "w" || e.key === "ArrowUp") input.throttleUp = true;
        if (e.key === "s" || e.key === "ArrowDown") input.throttleDown = true;
        if (e.key === "a" || e.key === "ArrowLeft") input.yawLeft = true;
        if (e.key === "d" || e.key === "ArrowRight") input.yawRight = true;
        if (e.key === "r" || e.key === "R") resetGame();
    });

    window.addEventListener("keyup", e => {
        keys[e.key] = false;
        if (e.key === "w" || e.key === "ArrowUp") input.throttleUp = false;
        if (e.key === "s" || e.key === "ArrowDown") input.throttleDown = false;
        if (e.key === "a" || e.key === "ArrowLeft") input.yawLeft = false;
        if (e.key === "d" || e.key === "ArrowRight") input.yawRight = false;
    });

    function bindTouchButton(btn, propName) {
        const activate = (ev) => {
            ev.preventDefault();
            input[propName] = true;
        };
        const deactivate = (ev) => {
            ev.preventDefault();
            input[propName] = false;
        };
        ["touchstart", "mousedown"].forEach(evt => {
            btn.addEventListener(evt, activate);
        });
        ["touchend", "touchcancel", "mouseup", "mouseleave"].forEach(evt => {
            btn.addEventListener(evt, deactivate);
        });
    }

    bindTouchButton(btnYawLeft,      "yawLeft");
    bindTouchButton(btnYawRight,     "yawRight");
    bindTouchButton(btnPitchUp,      "pitchUp");
    bindTouchButton(btnPitchDown,    "pitchDown");
    bindTouchButton(btnThrottleUp,   "throttleUp");
    bindTouchButton(btnThrottleDown, "throttleDown");

    // Uçuş durumu
    let speed = 0;               // kn (simülasyon)
    const minSpeed = 0;
    const maxSpeed = 420;
    let distanceTravelled = 0;   // metre
    let gameOver = false;
    let hasStarted = false;

    const clock = new THREE.Clock();

    function resetGame() {
        speed = 0;
        distanceTravelled = 0;
        gameOver = false;
        hasStarted = false;
        plane.position.set(0, 4, 0);
        plane.rotation.set(0, 0, 0);
        camera.position.set(-20, 10, 40);
        camera.lookAt(plane.position);
        hudStatus.textContent = "IDLE";
        hudSpeed.textContent = "0";
        hudAlt.textContent = "4";
        hudDist.textContent = "0.0";
        gameOverBanner.style.display = "none";
        startMessage.classList.remove("fade-out");
        startMessage.style.opacity = "1";
    }

    resetGame();
    resize();

    function update(dt) {
        if (gameOver) return;

        const throttlePower = 60;     // hızlanma
        const throttleBrake = 50;     // yavaşlama
        const airFriction = 15;       // doğal sürtünme
        const yawSpeed = THREE.MathUtils.degToRad(45); // derece/sn
        const pitchSpeed = THREE.MathUtils.degToRad(30);

        if (input.throttleUp) {
            speed += throttlePower * dt;
            hasStarted = true;
        }
        if (input.throttleDown) {
            speed -= throttleBrake * dt;
        }

        speed -= airFriction * dt;
        speed = THREE.MathUtils.clamp(speed, minSpeed, maxSpeed);

        if (speed > 5) {
            if (input.yawLeft && !input.yawRight) {
                plane.rotation.y += yawSpeed * dt;
            } else if (input.yawRight && !input.yawLeft) {
                plane.rotation.y -= yawSpeed * dt;
            }

            if (input.pitchUp && !input.pitchDown) {
                plane.rotation.z += pitchSpeed * dt * 0.4; // roll efekti
                plane.rotation.x -= pitchSpeed * dt;
            } else if (input.pitchDown && !input.pitchUp) {
                plane.rotation.z -= pitchSpeed * dt * 0.4;
                plane.rotation.x += pitchSpeed * dt;
            }
        }

        plane.rotation.x = THREE.MathUtils.clamp(plane.rotation.x, -0.6, 0.5);
        plane.rotation.z = THREE.MathUtils.clamp(plane.rotation.z, -0.6, 0.6);

        const forward = new THREE.Vector3(0, 0, -1).applyEuler(plane.rotation).normalize();
        const speedMetersPerSec = speed * 0.5; // tamamen uydurma ölçek
        const move = forward.clone().multiplyScalar(speedMetersPerSec * dt);
        plane.position.add(move);
        distanceTravelled += move.length();

        // Basit lift ve gravity
        const stallSpeed = 80;
        let lift = 0;
        if (speed > stallSpeed) {
            lift = (speed - stallSpeed) * 0.05 * Math.cos(plane.rotation.x);
        } else {
            lift = -10; // stall
        }
        plane.position.y += (lift * dt);

        if (plane.position.y < 1.5) {
            plane.position.y = 1.5;
            if (speed > 40) {
                triggerGameOver();
            }
        }

        if (plane.position.y > 800) {
            plane.position.y = 800;
        }

        const cameraOffset = new THREE.Vector3(0, 8, 25);
        cameraOffset.applyEuler(plane.rotation);
        const desiredCamPos = plane.position.clone().add(cameraOffset);
        camera.position.lerp(desiredCamPos, 0.08);
        const lookAtPoint = plane.position.clone().add(forward.clone().multiplyScalar(30));
        camera.lookAt(lookAtPoint);

        hudSpeed.textContent = speed.toFixed(0);
        hudAlt.textContent = plane.position.y.toFixed(0);
        hudDist.textContent = (distanceTravelled / 1000).toFixed(1);

        if (!hasStarted && speed < 5) {
            hudStatus.textContent = "IDLE";
        } else if (speed < 80) {
            hudStatus.textContent = "TAXI";
        } else if (speed < 160) {
            hudStatus.textContent = "CLIMB";
        } else if (speed < 260) {
            hudStatus.textContent = "CRUISE";
        } else {
            hudStatus.textContent = "FAST";
        }

        if (hasStarted && startMessage && startMessage.style.opacity !== "0") {
            startMessage.classList.add("fade-out");
        }
    }

    function triggerGameOver() {
        if (gameOver) return;
        gameOver = true;
        hudStatus.textContent = "CRASH";
        gameOverBanner.style.display = "block";
    }

    function render() {
        const dt = clock.getDelta();
        update(dt);
        renderer.render(scene, camera);
        requestAnimationFrame(render);
    }

    render();
})();
</script>
</body>
</html>
