<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8" />
    <title>SkyRunner 3D - Jet Takeoff</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: radial-gradient(circle at top, #071729 0%, #02040a 45%, #000000 100%);
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: transparent;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* HUD */
        .hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        #hud-info {
            position: absolute;
            top: 8px;
            left: 8px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.6);
            color: #0fef8f;
            font-size: 11px;
            letter-spacing: 0.08em;
            pointer-events: none;
            text-shadow: 0 0 4px #000;
        }

        #hud-sub {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.6);
            color: #ccccff;
            font-size: 11px;
            pointer-events: none;
            text-shadow: 0 0 4px #000;
        }

        .btn {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 999px;
            background:
                radial-gradient(circle at 25% 20%, #ffffffbb, #111827 55%, #020617 100%);
            box-shadow:
                0 0 0 1px #ffffff33,
                0 0 8px #020617;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #e5e7eb;
            font-size: 11px;
            text-align: center;
            pointer-events: auto;
            user-select: none;
            backdrop-filter: blur(6px);
        }

        .btn:active {
            transform: scale(0.95);
            box-shadow:
                0 0 0 1px #0fef8f99,
                0 0 18px #0fef8f55;
        }

        .btn-thr-up {
            bottom: 120px;
            left: 12px;
        }
        .btn-thr-down {
            bottom: 24px;
            left: 12px;
        }

        .btn-pitch-up {
            bottom: 120px;
            right: 12px;
        }
        .btn-pitch-down {
            bottom: 24px;
            right: 12px;
        }

        .btn-yaw-left {
            bottom: 24px;
            left: 110px;
            width: 70px;
            height: 70px;
        }

        .btn-yaw-right {
            bottom: 24px;
            left: 190px;
            width: 70px;
            height: 70px;
        }

        #hud-center {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 40px;
            height: 40px;
            margin-left: -20px;
            margin-top: -20px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 8px #000;
            pointer-events: none;
        }

        #hud-center::after {
            content: "";
            position: absolute;
            left: 50%;
            top: 50%;
            width: 4px;
            height: 4px;
            margin-left: -2px;
            margin-top: -2px;
            border-radius: 50%;
            background: #0fef8f;
        }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="game"></canvas>

    <div class="hud">
        <div id="hud-info">SPD 0 | ALT 0 | THR 0%</div>
        <div id="hud-sub">SKYRUNNER • JET TAKEOFF</div>
        <div id="hud-center"></div>

        <!-- Sol - Motor -->
        <div class="btn btn-thr-up">THR<br>+</div>
        <div class="btn btn-thr-down">THR<br>-</div>

        <!-- Sağ - Pitch -->
        <div class="btn btn-pitch-up">NOSE<br>UP</div>
        <div class="btn btn-pitch-down">NOSE<br>DOWN</div>

        <!-- Yaw -->
        <div class="btn btn-yaw-left">YAW<br>◀</div>
        <div class="btn btn-yaw-right">YAW<br>▶</div>
    </div>
</div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
(() => {
    const container = document.getElementById('game-container');
    const canvas = document.getElementById('game');

    const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true
    });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(0x02040a, 1);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020617, 0.0008);

    const camera = new THREE.PerspectiveCamera(
        60,
        container.clientWidth / container.clientHeight,
        0.1,
        8000
    );
    camera.position.set(0, 15, 45);

    // Işıklar
    const hemi = new THREE.HemisphereLight(0x8fbfff, 0x050811, 0.9);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xfff2cc, 1.1);
    dir.position.set(200, 300, 120);
    dir.castShadow = true;
    scene.add(dir);

    // "Güneş"
    const sunGeo = new THREE.SphereGeometry(50, 32, 32);
    const sunMat = new THREE.MeshBasicMaterial({ color: 0xfff4d2 });
    const sun = new THREE.Mesh(sunGeo, sunMat);
    sun.position.set(-800, 800, -1500);
    scene.add(sun);

    // Zemin
    const groundGeo = new THREE.PlaneGeometry(6000, 6000, 32, 32);
    const groundMat = new THREE.MeshStandardMaterial({
        color: 0x0b261b,
        roughness: 0.95,
        metalness: 0.0
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    // Pist
    const runwayGeo = new THREE.PlaneGeometry(1600, 60);
    const runwayMat = new THREE.MeshStandardMaterial({
        color: 0x22252b,
        roughness: 0.8,
        metalness: 0.2
    });
    const runway = new THREE.Mesh(runwayGeo, runwayMat);
    runway.rotation.x = -Math.PI / 2;
    runway.position.set(0, 0.02, 0);
    runway.receiveShadow = true;
    scene.add(runway);

    // Pist çizgileri
    const stripeMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.9,
        metalness: 0.0
    });
    for (let i = -750; i <= 750; i += 80) {
        const stripeGeo = new THREE.PlaneGeometry(18, 3);
        const stripe = new THREE.Mesh(stripeGeo, stripeMat);
        stripe.rotation.x = -Math.PI / 2;
        stripe.position.set(0, 0.03, i);
        scene.add(stripe);
    }

    // Yan kenar çizgileri
    const edgeMat = new THREE.MeshStandardMaterial({
        color: 0xfafafa,
        roughness: 0.95,
        metalness: 0.0
    });
    const edgeGeo = new THREE.PlaneGeometry(1600, 1.5);
    const leftEdge = new THREE.Mesh(edgeGeo, edgeMat);
    const rightEdge = new THREE.Mesh(edgeGeo, edgeMat);
    leftEdge.rotation.x = -Math.PI / 2;
    rightEdge.rotation.x = -Math.PI / 2;
    leftEdge.position.set(-27, 0.03, 0);
    rightEdge.position.set(27, 0.03, 0);
    scene.add(leftEdge, rightEdge);

    // Basit bulutlar (yukarıda, hafif hareketli)
    const clouds = [];
    const cloudMat = new THREE.MeshLambertMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.75
    });
    for (let i = 0; i < 25; i++) {
        const cg = new THREE.SphereGeometry(THREE.MathUtils.randFloat(40, 80), 12, 12);
        const cm = new THREE.Mesh(cg, cloudMat);
        const radius = THREE.MathUtils.randFloat(400, 1500);
        const angle = Math.random() * Math.PI * 2;
        cm.position.set(
            Math.cos(angle) * radius,
            THREE.MathUtils.randFloat(160, 260),
            Math.sin(angle) * radius
        );
        cm.scale.set(
            THREE.MathUtils.randFloat(1.2, 1.8),
            THREE.MathUtils.randFloat(0.6, 1.2),
            THREE.MathUtils.randFloat(1.2, 1.8)
        );
        scene.add(cm);
        clouds.push(cm);
    }

    // -------------------------------------------------------------------------
    // UÇAK MODELİ (Detaylı, animasyonlu, şık jet)
    // -------------------------------------------------------------------------
    //
    // Bu bölümde:
    //  - Gövde segmentleri
    //  - Burun + radar cone
    //  - Kokpit canopy ve frame
    //  - Kanatlar, flaps, elevonlar
    //  - Dikey stabilizatörler / rudder
    //  - Canard'lar (öndeki küçük kanatlar)
    //  - Çift motor nozulu + afterburner glow
    //  - İniş takımı (burun teker, ana tekerler, amörtisör)
    //  - Gövde altı yakıt tankı
    //  - Kanat altı füzeleri
    //  - Navigasyon ışıkları (yanlarda kırmızı/yeşil, kuyrukta beyaz)
    //  - Jet üstünde hafif panel detayları için küçük box/cylinder eklemeleri
    //
    // Bu sayede:
    //  - Uçak yerdeyken iniş takımı açık,
    //  - Havadayken hız ve irtifaya göre iniş takımı kapanmış gibi davranacak,
    //  - Flap ve rudder'lar pitch/yaw girişine göre hafif oynayacak,
    //  - Afterburner, throttle'a göre parlayacak ve titreşecek,
    //  - Navigasyon ışıkları zamanla yanıp sönecek.
    //
    // NOT: Aşağıdaki modellendirme tamamen Three.js primitifleri ile yapılıyor
    // (BoxGeometry, CylinderGeometry, ConeGeometry, SphereGeometry vs.).
    // Her parça tek tek konumlandırılıp, döndürülüp jet grubuna ekleniyor.
    // -------------------------------------------------------------------------

    const jet = new THREE.Group();

    // Jet bileşen referansları
    let leftWing;
    let rightWing;
    let tail;

    let flapL;
    let flapR;
    let elevonL;
    let elevonR;

    let rudderL;
    let rudderR;

    let canardL;
    let canardR;

    let noseWheel;
    let mainWheelL;
    let mainWheelR;
    let gearStrutN;
    let gearStrutL;
    let gearStrutR;

    let leftNavLight;
    let rightNavLight;
    let tailNavLight;

    let glowL;
    let glowR;

    // -----------------------------------------------------------
    // MALZEMELER (Tekrar kullanılacak malzeme setleri)
    // -----------------------------------------------------------

    const hullMetalMaterial = new THREE.MeshStandardMaterial({
        color: 0x1e293b,
        metalness: 0.9,
        roughness: 0.32
    });

    const accentBlueMaterial = new THREE.MeshStandardMaterial({
        color: 0x2563eb,
        metalness: 0.92,
        roughness: 0.25
    });

    const accentDarkBlueMaterial = new THREE.MeshStandardMaterial({
        color: 0x1d4ed8,
        metalness: 0.92,
        roughness: 0.35
    });

    const engineMetalMaterial = new THREE.MeshStandardMaterial({
        color: 0x020617,
        metalness: 0.95,
        roughness: 0.4
    });

    const wheelRubberMaterial = new THREE.MeshStandardMaterial({
        color: 0x020617,
        metalness: 0.2,
        roughness: 0.9
    });

    const strutMetalMaterial = new THREE.MeshStandardMaterial({
        color: 0xe5e7eb,
        metalness: 0.9,
        roughness: 0.3
    });

    const missileBodyMaterial = new THREE.MeshStandardMaterial({
        color: 0xf9fafb,
        metalness: 0.4,
        roughness: 0.5
    });

    const missileNoseMaterial = new THREE.MeshStandardMaterial({
        color: 0x9ca3af,
        metalness: 0.8,
        roughness: 0.2
    });

    const tankMaterial = new THREE.MeshStandardMaterial({
        color: 0x0f172a,
        metalness: 0.9,
        roughness: 0.3
    });

    const panelMaterial = new THREE.MeshStandardMaterial({
        color: 0x111827,
        metalness: 0.7,
        roughness: 0.5
    });

    const canopyOuterMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x93c5fd,
        roughness: 0.05,
        metalness: 0.1,
        transparent: true,
        opacity: 0.65,
        reflectivity: 1.0,
        clearcoat: 0.9
    });

    const canopyFrameMaterial = new THREE.MeshStandardMaterial({
        color: 0x020617,
        metalness: 0.9,
        roughness: 0.35
    });

    const navRedMaterial = new THREE.MeshBasicMaterial({
        color: 0xef4444,
        transparent: true,
        opacity: 0.9
    });

    const navGreenMaterial = new THREE.MeshBasicMaterial({
        color: 0x22c55e,
        transparent: true,
        opacity: 0.9
    });

    const navWhiteMaterial = new THREE.MeshBasicMaterial({
        color: 0xf9fafb,
        transparent: true,
        opacity: 0.9
    });

    const afterburnerMat = new THREE.MeshBasicMaterial({
        color: 0x60a5fa,
        transparent: true,
        opacity: 0.0
    });

    // ---------------------------------------------
    // GÖVDE SEGMENTLERİ
    // ---------------------------------------------
    //
    // Gövdeyi tek bir cylinder yerine 3 bölümden oluşturuyoruz:
    //  1) Ön gövde: buruna doğru incelen kısım
    //  2) Orta gövde: kanatların bağlandığı ana bölüm
    //  3) Arka gövde: motorlara yakın hafif daralan kısım
    //
    // Bu parçalara ek olarak üstte hafif panel/omurga çizgisi için birkaç
    // ince box/cylinder ekleyerek görsel olarak daha "military jet" havası veriyoruz.
    // ---------------------------------------------

    const frontHullGeo = new THREE.CylinderGeometry(
        0.7, 1.0, 8.0, 24, 1, false
    );
    const frontHull = new THREE.Mesh(
        frontHullGeo,
        hullMetalMaterial
    );
    frontHull.rotation.z = Math.PI / 2;
    frontHull.position.set(4.0, 0.1, 0);
    frontHull.castShadow = true;
    jet.add(frontHull);

    const midHullGeo = new THREE.CylinderGeometry(
        1.0, 1.0, 8.5, 26, 1, false
    );
    const midHull = new THREE.Mesh(
        midHullGeo,
        hullMetalMaterial
    );
    midHull.rotation.z = Math.PI / 2;
    midHull.position.set(-0.2, 0.0, 0);
    midHull.castShadow = true;
    jet.add(midHull);

    const rearHullGeo = new THREE.CylinderGeometry(
        0.9, 1.0, 7.0, 22, 1, false
    );
    const rearHull = new THREE.Mesh(
        rearHullGeo,
        hullMetalMaterial
    );
    rearHull.rotation.z = Math.PI / 2;
    rearHull.position.set(-5.5, -0.1, 0);
    rearHull.castShadow = true;
    jet.add(rearHull);

    // Gövde üst omurga/panel
    for (let i = -6; i <= 4; i += 2) {
        const spineGeo = new THREE.BoxGeometry(
            0.7,
            0.12,
            0.6
        );
        const spine = new THREE.Mesh(
            spineGeo,
            panelMaterial
        );
        spine.position.set(
            i,
            0.8,
            0
        );
        spine.castShadow = true;
        jet.add(spine);
    }

    // ---------------------------------------------
    // BURUN + RADAR CONE
    // ---------------------------------------------
    //
    // Uçak burnunu iki konik parçadan oluşturuyoruz:
    //  - Uzun, sivri ana burun konisi
    //  - Daha koyu renkli kısa radar konisi
    // ---------------------------------------------

    const noseGeo = new THREE.ConeGeometry(
        1.05,
        3.5,
        28
    );
    const nose = new THREE.Mesh(
        noseGeo,
        accentBlueMaterial
    );
    nose.position.set(7.8, 0.0, 0);
    nose.rotation.z = Math.PI / 2;
    nose.castShadow = true;
    jet.add(nose);

    const noseTipGeo = new THREE.ConeGeometry(
        0.6,
        1.5,
        24
    );
    const noseTip = new THREE.Mesh(
        noseTipGeo,
        engineMetalMaterial
    );
    noseTip.position.set(9.3, 0, 0);
    noseTip.rotation.z = Math.PI / 2;
    noseTip.castShadow = true;
    jet.add(noseTip);

    // ---------------------------------------------
    // KOKPİT CANOPY + FRAME
    // ---------------------------------------------
    //
    // Canopy = yarım kubbe + ön cam
    // Frame = canopy etrafında ince metal şerit
    // ---------------------------------------------

    const canopyGeo = new THREE.SphereGeometry(
        1.2,
        28,
        18,
        0,
        Math.PI * 2,
        0,
        Math.PI / 1.8
    );
    const canopy = new THREE.Mesh(
        canopyGeo,
        canopyOuterMaterial
    );
    canopy.position.set(
        2.3,
        0.85,
        0
    );
    canopy.rotation.z = Math.PI / 2;
    canopy.castShadow = true;
    jet.add(canopy);

    const canopyFrameGeo = new THREE.TorusGeometry(
        1.18,
        0.06,
        10,
        30
    );
    const canopyFrame = new THREE.Mesh(
        canopyFrameGeo,
        canopyFrameMaterial
    );
    canopyFrame.position.set(
        2.3,
        0.86,
        0
    );
    canopyFrame.rotation.y = Math.PI / 2;
    canopyFrame.castShadow = true;
    jet.add(canopyFrame);

    // ---------------------------------------------
    // KANATLAR + FLAP + ELEVON
    // ---------------------------------------------
    //
    // Ana kanat: geniş bir delta kanat
    // Flap: iç tarafta ayrı box
    // Elevon: uç tarafında küçük hareketli parça
    // ---------------------------------------------

    const mainWingGeo = new THREE.BoxGeometry(
        8.4,
        0.18,
        2.6
    );

    const flapGeo = new THREE.BoxGeometry(
        3.4,
        0.16,
        0.8
    );

    const elevonGeo = new THREE.BoxGeometry(
        2.0,
        0.14,
        0.7
    );

    // Sol ana kanat
    leftWing = new THREE.Mesh(
        mainWingGeo,
        accentDarkBlueMaterial
    );
    leftWing.position.set(
        -0.6,
        0.0,
        -3.2
    );
    leftWing.rotation.x = THREE.MathUtils.degToRad(3);
    leftWing.rotation.y = THREE.MathUtils.degToRad(2);
    leftWing.castShadow = true;
    jet.add(leftWing);

    // Sağ ana kanat
    rightWing = new THREE.Mesh(
        mainWingGeo,
        accentDarkBlueMaterial
    );
    rightWing.position.set(
        -0.6,
        0.0,
        3.2
    );
    rightWing.rotation.x = THREE.MathUtils.degToRad(-3);
    rightWing.rotation.y = THREE.MathUtils.degToRad(-2);
    rightWing.castShadow = true;
    jet.add(rightWing);

    // Sol flap
    flapL = new THREE.Mesh(
        flapGeo,
        hullMetalMaterial
    );
    flapL.position.set(
        -1.0,
        -0.05,
        -3.1
    );
    flapL.castShadow = true;
    jet.add(flapL);

    // Sağ flap
    flapR = new THREE.Mesh(
        flapGeo,
        hullMetalMaterial
    );
    flapR.position.set(
        -1.0,
        -0.05,
        3.1
    );
    flapR.castShadow = true;
    jet.add(flapR);

    // Sol elevon
    elevonL = new THREE.Mesh(
        elevonGeo,
        accentBlueMaterial
    );
    elevonL.position.set(
        -3.9,
        -0.03,
        -3.0
    );
    elevonL.castShadow = true;
    jet.add(elevonL);

    // Sağ elevon
    elevonR = new THREE.Mesh(
        elevonGeo,
        accentBlueMaterial
    );
    elevonR.position.set(
        -3.9,
        -0.03,
        3.0
    );
    elevonR.castShadow = true;
    jet.add(elevonR);

    // ---------------------------------------------
    // KUYRUK KANATLARI + DİKEY STABİLİZATÖR (RUDDER)
    // ---------------------------------------------

    const tailWingGeo = new THREE.BoxGeometry(
        4.0,
        0.16,
        1.6
    );
    tail = new THREE.Mesh(
        tailWingGeo,
        accentBlueMaterial
    );
    tail.position.set(
        -6.2,
        0.35,
        0
    );
    tail.rotation.x = THREE.MathUtils.degToRad(5);
    tail.castShadow = true;
    jet.add(tail);

    const vTailGeo = new THREE.BoxGeometry(
        0.22,
        2.2,
        1.1
    );
    rudderL = new THREE.Mesh(
        vTailGeo,
        accentDarkBlueMaterial
    );
    rudderR = new THREE.Mesh(
        vTailGeo,
        accentDarkBlueMaterial
    );

    rudderL.position.set(
        -6.4,
        1.1,
        -0.9
    );
    rudderR.position.set(
        -6.4,
        1.1,
        0.9
    );

    rudderL.rotation.x = THREE.MathUtils.degToRad(14);
    rudderR.rotation.x = THREE.MathUtils.degToRad(14);

    rudderL.castShadow = true;
    rudderR.castShadow = true;

    jet.add(rudderL);
    jet.add(rudderR);

    // ---------------------------------------------
    // CANARD’LAR (ÖNDEKİ KÜÇÜK KANATLAR)
    // ---------------------------------------------

    const canardGeo = new THREE.BoxGeometry(
        2.4,
        0.12,
        0.8
    );
    canardL = new THREE.Mesh(
        canardGeo,
        accentBlueMaterial
    );
    canardR = new THREE.Mesh(
        canardGeo,
        accentBlueMaterial
    );

    canardL.position.set(
        3.8,
        0.4,
        -1.6
    );
    canardR.position.set(
        3.8,
        0.4,
        1.6
    );

    canardL.rotation.y = THREE.MathUtils.degToRad(6);
    canardR.rotation.y = THREE.MathUtils.degToRad(-6);

    canardL.castShadow = true;
    canardR.castShadow = true;

    jet.add(canardL);
    jet.add(canardR);

    // ---------------------------------------------
    // ÇİFT MOTOR + AFTERBURNER
    // ---------------------------------------------

    const engineGeo = new THREE.CylinderGeometry(
        0.6,
        0.9,
        2.6,
        20
    );
    const engineL = new THREE.Mesh(
        engineGeo,
        engineMetalMaterial
    );
    const engineR = new THREE.Mesh(
        engineGeo,
        engineMetalMaterial
    );

    engineL.rotation.z = Math.PI / 2;
    engineR.rotation.z = Math.PI / 2;

    engineL.position.set(
        -7.5,
        -0.25,
        -0.9
    );
    engineR.position.set(
        -7.5,
        -0.25,
        0.9
    );

    engineL.castShadow = true;
    engineR.castShadow = true;

    jet.add(engineL);
    jet.add(engineR);

    const glowGeo = new THREE.SphereGeometry(
        0.95,
        20,
        20
    );
    glowL = new THREE.Mesh(
        glowGeo,
        afterburnerMat
    );
    glowR = new THREE.Mesh(
        glowGeo,
        afterburnerMat
    );

    glowL.position.set(
        -8.9,
        -0.25,
        -0.9
    );
    glowR.position.set(
        -8.9,
        -0.25,
        0.9
    );

    jet.add(glowL);
    jet.add(glowR);

    // ---------------------------------------------
    // İNİŞ TAKIMI (BURUN TEKER + ANA TEKERLER)
    // ---------------------------------------------

    // Burun teker strut
    const noseStrutGeo = new THREE.CylinderGeometry(
        0.08,
        0.08,
        1.4,
        10
    );
    gearStrutN = new THREE.Mesh(
        noseStrutGeo,
        strutMetalMaterial
    );
    gearStrutN.rotation.z = Math.PI / 2;
    gearStrutN.position.set(
        4.2,
        -0.9,
        0
    );
    gearStrutN.castShadow = true;
    jet.add(gearStrutN);

    // Burun teker
    const noseWheelGeo = new THREE.TorusGeometry(
        0.32,
        0.12,
        10,
        20
    );
    noseWheel = new THREE.Mesh(
        noseWheelGeo,
        wheelRubberMaterial
    );
    noseWheel.rotation.y = Math.PI / 2;
    noseWheel.position.set(
        4.9,
        -1.1,
        0
    );
    noseWheel.castShadow = true;
    jet.add(noseWheel);

    // Ana strut’lar
    const mainStrutGeo = new THREE.CylinderGeometry(
        0.1,
        0.1,
        1.6,
        10
    );
    gearStrutL = new THREE.Mesh(
        mainStrutGeo,
        strutMetalMaterial
    );
    gearStrutR = new THREE.Mesh(
        mainStrutGeo,
        strutMetalMaterial
    );
    gearStrutL.rotation.z = Math.PI / 2;
    gearStrutR.rotation.z = Math.PI / 2;

    gearStrutL.position.set(
        -1.0,
        -0.95,
        -1.8
    );
    gearStrutR.position.set(
        -1.0,
        -0.95,
        1.8
    );

    gearStrutL.castShadow = true;
    gearStrutR.castShadow = true;

    jet.add(gearStrutL);
    jet.add(gearStrutR);

    // Ana tekerler
    const mainWheelGeo = new THREE.TorusGeometry(
        0.45,
        0.16,
        12,
        24
    );
    mainWheelL = new THREE.Mesh(
        mainWheelGeo,
        wheelRubberMaterial
    );
    mainWheelR = new THREE.Mesh(
        mainWheelGeo,
        wheelRubberMaterial
    );

    mainWheelL.rotation.y = Math.PI / 2;
    mainWheelR.rotation.y = Math.PI / 2;

    mainWheelL.position.set(
        -1.9,
        -1.2,
        -1.8
    );
    mainWheelR.position.set(
        -1.9,
        -1.2,
        1.8
    );

    mainWheelL.castShadow = true;
    mainWheelR.castShadow = true;

    jet.add(mainWheelL);
    jet.add(mainWheelR);

    // ---------------------------------------------
    // GÖVDE ALTI YAKIT TANKI
    // ---------------------------------------------

    const tankGeo = new THREE.CapsuleGeometry(
        0.5,
        3.6,
        8,
        16
    );
    const tank = new THREE.Mesh(
        tankGeo,
        tankMaterial
    );
    tank.position.set(
        -0.8,
        -0.8,
        0
    );
    tank.rotation.z = Math.PI / 2;
    tank.castShadow = true;
    jet.add(tank);

    // ---------------------------------------------
    // KANAT ALTI FÜZELER
    // ---------------------------------------------

    const missileBodyGeo = new THREE.CylinderGeometry(
        0.18,
        0.2,
        2.4,
        12
    );
    const missileNoseGeo = new THREE.ConeGeometry(
        0.19,
        0.7,
        12
    );
    const missileFinGeo = new THREE.BoxGeometry(
        0.02,
        0.4,
        0.25
    );

    function createMissile(offsetZ) {
        const missile = new THREE.Group();

        const body = new THREE.Mesh(
            missileBodyGeo,
            missileBodyMaterial
        );
        body.rotation.z = Math.PI / 2;
        body.castShadow = true;
        missile.add(body);

        const nose = new THREE.Mesh(
            missileNoseGeo,
            missileNoseMaterial
        );
        nose.position.set(
            1.3,
            0,
            0
        );
        nose.rotation.z = Math.PI / 2;
        nose.castShadow = true;
        missile.add(nose);

        // 4 adet fin
        for (let i = 0; i < 4; i++) {
            const fin = new THREE.Mesh(
                missileFinGeo,
                panelMaterial
            );
            const angle = (Math.PI / 2) * i;
            const r = 0.25;
            fin.position.set(
                -0.2,
                Math.cos(angle) * r,
                Math.sin(angle) * r
            );
            fin.castShadow = true;
            missile.add(fin);
        }

        // Pozisyon: kanadın altında
        missile.position.set(
            -1.0,
            -0.4,
            offsetZ
        );

        return missile;
    }

    const missileL1 = createMissile(-3.6);
    const missileR1 = createMissile(3.6);
    const missileL2 = createMissile(-2.5);
    const missileR2 = createMissile(2.5);

    jet.add(missileL1);
    jet.add(missileR1);
    jet.add(missileL2);
    jet.add(missileR2);

    // ---------------------------------------------
    // NAVİGASYON IŞIKLARI
    // ---------------------------------------------
    //
    //  - Sol kanat ucu: kırmızı
    //  - Sağ kanat ucu: yeşil
    //  - Kuyruk ucu: beyaz
    //  - updateJetPhysics içinde t zamanına göre yanıp sönecek
    // ---------------------------------------------

    const navLightGeo = new THREE.SphereGeometry(
        0.22,
        10,
        10
    );

    leftNavLight = new THREE.Mesh(
        navLightGeo,
        navRedMaterial
    );
    rightNavLight = new THREE.Mesh(
        navLightGeo,
        navGreenMaterial
    );
    tailNavLight = new THREE.Mesh(
        navLightGeo,
        navWhiteMaterial
    );

    leftNavLight.position.set(
        -4.5,
        0.1,
        -4.1
    );
    rightNavLight.position.set(
        -4.5,
        0.1,
        4.1
    );
    tailNavLight.position.set(
        -7.4,
        0.6,
        0
    );

    jet.add(leftNavLight);
    jet.add(rightNavLight);
    jet.add(tailNavLight);

    // ---------------------------------------------
    // JETİN GLOBAL POZİSYONU
    // ---------------------------------------------

    jet.position.set(
        0,
        2.4,
        700
    ); // pistin bir ucunda
    jet.rotation.set(
        0,
        Math.PI,
        0
    ); // -Z yönüne bakıyor
    scene.add(jet);

    // -----------------------
    // FİZİK & KONTROLLER
    // -----------------------
    let throttle = 0;
    let speed = 0;
    let yawInput = 0;
    let pitchInput = 0;
    let verticalSpeed = 0;
    let airborne = false;

    const maxSpeed = 210;
    const accel = 35;
    const drag = 0.02;
    const gravity = -9.8;
    const liftFactor = 35;
    const takeoffSpeed = 90;

    const hudInfo = document.getElementById("hud-info");

    function updateHUD() {
        const alt = Math.max(0, jet.position.y - 2.4);
        const thr = Math.round(throttle * 100);
        const spdKts = Math.round(speed * 1.94384);
        hudInfo.textContent = `SPD ${spdKts} KT | ALT ${alt.toFixed(0)} m | THR ${thr}%`;
    }

    // AFTERBURNER GÜNCELLEME
    function updateAfterburner(t, dt) {
        const power = throttle;

        const baseOpacity = power * 0.9;
        const flicker = 0.18 * Math.sin(t * 45) * power;
        const o = THREE.MathUtils.clamp(
            baseOpacity + flicker,
            0,
            0.95
        );
        afterburnerMat.opacity = o;

        const color = new THREE.Color().setHSL(
            0.62 - 0.18 * power,
            0.9,
            0.6 + 0.22 * power
        );
        afterburnerMat.color.copy(color);

        const scaleBase = 1.05 + 1.3 * power;
        const scaleFlicker = 0.23 * Math.sin(t * 33) * power;
        const s = scaleBase + scaleFlicker;

        glowL.scale.setScalar(s);
        glowR.scale.setScalar(s);
    }

    // NAVİGASYON IŞIKLARI GÜNCELLEME
    function updateNavLights(t) {
        const blink = 0.5 + 0.5 * Math.sin(t * 4.0);    // 0..1 arası
        const blinkFast = 0.5 + 0.5 * Math.sin(t * 9.0);

        leftNavLight.material.opacity = 0.3 + 0.7 * blink;
        rightNavLight.material.opacity = 0.3 + 0.7 * blinkFast;
        tailNavLight.material.opacity = 0.4 + 0.5 * blink;
    }

    // İNİŞ TAKIMI GÜNCELLEME
    function updateLandingGear(dt) {
        const targetVisible = !airborne || speed < 120;

        const targetScale = targetVisible ? 1.0 : 0.0;
        const lerpFactor = 5.0 * dt;

        function lerpScale(obj) {
            if (!obj) return;
            const current = obj.scale.y;
            const newScaleY = THREE.MathUtils.lerp(
                current,
                targetScale,
                lerpFactor
            );
            obj.scale.y = newScaleY;
            obj.scale.x = newScaleY;
            obj.scale.z = newScaleY;
        }

        lerpScale(noseWheel);
        lerpScale(mainWheelL);
        lerpScale(mainWheelR);
        lerpScale(gearStrutN);
        lerpScale(gearStrutL);
        lerpScale(gearStrutR);
    }

    // FLAP / ELEVON / RUDDER / CANARD ANİMASYON
    function updateControlSurfaces(dt) {
        const flapTarget = THREE.MathUtils.degToRad(
            pitchInput * -12
        );
        const elevonTarget = THREE.MathUtils.degToRad(
            pitchInput * -16
        );
        const canardTarget = THREE.MathUtils.degToRad(
            pitchInput * -18
        );
        const rudderTarget = THREE.MathUtils.degToRad(
            yawInput * -22
        );

        const factor = 10 * dt;

        if (flapL && flapR) {
            flapL.rotation.x = THREE.MathUtils.lerp(
                flapL.rotation.x,
                flapTarget,
                factor
            );
            flapR.rotation.x = THREE.MathUtils.lerp(
                flapR.rotation.x,
                flapTarget,
                factor
            );
        }

        if (elevonL && elevonR) {
            elevonL.rotation.x = THREE.MathUtils.lerp(
                elevonL.rotation.x,
                elevonTarget,
                factor
            );
            elevonR.rotation.x = THREE.MathUtils.lerp(
                elevonR.rotation.x,
                elevonTarget,
                factor
            );
        }

        if (canardL && canardR) {
            canardL.rotation.z = THREE.MathUtils.lerp(
                canardL.rotation.z,
                canardTarget,
                factor
            );
            canardR.rotation.z = THREE.MathUtils.lerp(
                canardR.rotation.z,
                -canardTarget,
                factor
            );
        }

        if (rudderL && rudderR) {
            rudderL.rotation.y = THREE.MathUtils.lerp(
                rudderL.rotation.y,
                rudderTarget,
                factor
            );
            rudderR.rotation.y = THREE.MathUtils.lerp(
                rudderR.rotation.y,
                rudderTarget,
                factor
            );
        }

        // Burun tekeri yönlendirme (hafif)
        if (noseWheel && !airborne) {
            const steerTarget = THREE.MathUtils.degToRad(
                yawInput * 30
            );
            const steerFactor = 8 * dt;
            noseWheel.rotation.z = THREE.MathUtils.lerp(
                noseWheel.rotation.z,
                steerTarget,
                steerFactor
            );
        }
    }

    function updateJetPhysics(dt, t) {
        const targetSpeed = throttle * maxSpeed;
        const diff = targetSpeed - speed;
        speed += diff * Math.min(1, accel * dt);
        speed *= (1 - drag * dt);
        if (speed < 0.01) speed = 0;

        // Yaw - sağ/sol yönlendirme
        const yawRate = 0.7;
        jet.rotation.y += yawInput * yawRate * dt;

        // Pitch - burun hareketi
        const pitchRate = 0.45;
        jet.rotation.x += pitchInput * pitchRate * dt;
        jet.rotation.x = THREE.MathUtils.clamp(
            jet.rotation.x,
            -0.6,
            0.4
        );

        // Hafif roll efekti (sanki aileronlar devrede)
        const rollTarget = yawInput * THREE.MathUtils.degToRad(-20);
        const rollAutoPitch = pitchInput * THREE.MathUtils.degToRad(5);
        const rollCurrent = jet.rotation.z;
        const rollDiff = (rollTarget + rollAutoPitch) - rollCurrent;
        jet.rotation.z += rollDiff * 3 * dt;

        // İleri hareket (uçağın baktığı yönde)
        const forward = new THREE.Vector3(0, 0, -1);
        forward.applyQuaternion(jet.quaternion);
        jet.position.addScaledVector(forward, speed * dt);

        // Kalkış / iniş
        if (!airborne) {
            jet.position.y = 2.4; // teker pistte

            if (speed > takeoffSpeed && pitchInput < -0.15) {
                airborne = true;
                verticalSpeed = 11;
            }
        } else {
            const angleOfAttack = -jet.rotation.x;
            const lift = Math.max(0, angleOfAttack * liftFactor);
            verticalSpeed += (gravity + lift) * dt;
            jet.position.y += verticalSpeed * dt;

            const groundLevel = 2.4;
            if (jet.position.y <= groundLevel) {
                jet.position.y = groundLevel;
                if (verticalSpeed < -20) {
                    verticalSpeed = 7;
                } else {
                    verticalSpeed = 0;
                    if (speed < 70 && Math.abs(angleOfAttack) < 0.2) {
                        airborne = false;
                    }
                }
            }
        }

        // Kamera takip
        const camOffset = new THREE.Vector3(0, 8, 30);
        camOffset.applyQuaternion(jet.quaternion);
        const desiredCamPos = jet.position.clone().add(camOffset);
        camera.position.lerp(desiredCamPos, 0.08);
        const lookTarget = jet.position.clone().add(new THREE.Vector3(0, 2.5, 0));
        camera.lookAt(lookTarget);

        // Kanatlara hafif animasyon (mevcut + biraz daha canlılık)
        const wingOsc = Math.sin(t * 6) * 0.02 * throttle;
        if (leftWing && rightWing && tail) {
            leftWing.rotation.x = THREE.MathUtils.degToRad(3) + wingOsc;
            rightWing.rotation.x = THREE.MathUtils.degToRad(-3) - wingOsc;
            tail.rotation.y = yawInput * THREE.MathUtils.degToRad(8);
        }

        updateControlSurfaces(dt);
        updateLandingGear(dt);
        updateAfterburner(t, dt);
        updateNavLights(t);
        updateHUD();
    }

    // Dokunmatik / mouse butonları
    function bindButton(selector, onPress, onRelease) {
        const el = document.querySelector(selector);
        if (!el) return;

        const start = (ev) => {
            ev.preventDefault();
            onPress();
        };
        const end = (ev) => {
            ev.preventDefault();
            onRelease();
        };

        el.addEventListener('touchstart', start, { passive: false });
        el.addEventListener('touchend', end, { passive: false });
        el.addEventListener('touchcancel', end, { passive: false });

        el.addEventListener('mousedown', start);
        window.addEventListener('mouseup', end);
    }

    // Motor +/-
    bindButton('.btn-thr-up',
        () => { throttle = Math.min(1, throttle + 0.02); },
        () => {}
    );
    bindButton('.btn-thr-down',
        () => { throttle = Math.max(0, throttle - 0.02); },
        () => {}
    );

    // Pitch
    bindButton('.btn-pitch-up',
        () => { pitchInput = -1; },
        () => { pitchInput = 0; }
    );
    bindButton('.btn-pitch-down',
        () => { pitchInput = 1; },
        () => { pitchInput = 0; }
    );

    // Yaw
    bindButton('.btn-yaw-left',
        () => { yawInput = -1; },
        () => { yawInput = 0; }
    );
    bindButton('.btn-yaw-right',
        () => { yawInput = 1; },
        () => { yawInput = 0; }
    );

    // Bulutları hafif hareket ettir
    function updateClouds(dt) {
        clouds.forEach(c => {
            c.position.x += 2 * dt;
            c.position.z += 1 * dt;
            const r = Math.sqrt(
                c.position.x * c.position.x +
                c.position.z * c.position.z
            );
            if (r > 2200) {
                const angle = Math.random() * Math.PI * 2;
                const radius = THREE.MathUtils.randFloat(600, 1800);
                c.position.set(
                    Math.cos(angle) * radius,
                    THREE.MathUtils.randFloat(160, 260),
                    Math.sin(angle) * radius
                );
            }
        });
    }

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const t = clock.elapsedTime;

        updateJetPhysics(dt, t);
        updateClouds(dt);

        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        const w = container.clientWidth;
        const h = container.clientHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
    });
})();
</script>
</body>
</html>
