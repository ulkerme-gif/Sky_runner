<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8" />
    <title>SkyRunner 3D - Su-27 Advanced</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* HUD */
        .hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .hud-top-left {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            font-size: 11px;
            max-width: 280px;
            backdrop-filter: blur(6px);
        }

        .hud-top-left h1 {
            font-size: 14px;
            margin-bottom: 4px;
        }

        .hud-top-left p {
            opacity: 0.9;
            line-height: 1.4;
        }

        .hud-top-center {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            font-size: 11px;
            backdrop-filter: blur(6px);
        }

        .hud-chip {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .hud-label {
            font-size: 10px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .hud-value {
            font-size: 13px;
            font-weight: 600;
        }

        .hud-top-right {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 6px 10px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            font-size: 11px;
            backdrop-filter: blur(6px);
        }

        .hud-top-right div {
            margin-bottom: 2px;
        }

        .hud-bottom-center {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.4);
            color: #fff;
            font-size: 11px;
            backdrop-filter: blur(6px);
        }

        /* Dokunmatik kontroller – biraz yukarıda */
        .touch-controls {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .pad-left,
        .pad-right {
            position: absolute;
            bottom: 80px;
            width: 46%;
            max-width: 280px;
            height: 40%;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 10px;
            pointer-events: auto;
        }

        .pad-left {
            left: 6px;
        }

        .pad-right {
            right: 6px;
        }

        .ctrl-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .ctrl-row {
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        .ctrl-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: none;
            background: radial-gradient(circle at 30% 30%, #ffffff, #bfc3c7);
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.6);
            font-size: 22px;
            font-weight: 700;
            color: #333;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        .ctrl-btn.small {
            width: 52px;
            height: 52px;
            font-size: 18px;
        }

        .ctrl-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 rgba(0, 0, 0, 0.7);
        }

        .ctrl-label {
            text-align: center;
            color: #fff;
            font-size: 11px;
            margin-top: 2px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.9);
        }

        /* Reticle */
        .reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid rgba(0, 255, 0, 0.85);
            box-shadow: 0 0 10px rgba(0,255,0,0.8);
            pointer-events: none;
        }

        .reticle::before,
        .reticle::after {
            content: "";
            position: absolute;
            background: rgba(0,255,0,0.7);
        }

        .reticle::before {
            width: 130%;
            height: 1px;
            top: 50%;
            left: -15%;
        }

        .reticle::after {
            width: 1px;
            height: 130%;
            left: 50%;
            top: -15%;
        }

        .center-message {
            position: absolute;
            top: 22%;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 16px;
            border-radius: 14px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            text-align: center;
            font-size: 12px;
            max-width: 320px;
            pointer-events: none;
            backdrop-filter: blur(6px);
        }

        .center-message-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .center-message-sub {
            opacity: 0.9;
        }

        .fade-out {
            animation: fadeOut 0.7s forwards;
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to   { opacity: 0; visibility: hidden; }
        }

        .game-over-banner {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 16px;
            border-radius: 10px;
            background: rgba(120, 0, 0, 0.88);
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            pointer-events: none;
            display: none;
        }

        .game-over-banner span {
            display: block;
            font-size: 11px;
            font-weight: 400;
            margin-top: 4px;
            opacity: 0.9;
        }

        @media (max-width: 768px) {
            .hud-top-left { font-size: 11px; max-width: 250px; }
            .hud-top-center { font-size: 11px; }
            .hud-value { font-size: 13px; }
        }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="hud">
        <div class="hud-top-left">
            <h1>SkyRunner 3D - Su-27</h1>
            <p>
                Tablet: Sol pad <strong>yaw / roll</strong>, sağ pad <strong>pitch</strong>, <strong>gaz</strong>, <strong>iniş takımı</strong>, <strong>motor</strong>.<br/>
                Klavye: W/S (gaz), A/D (yaw+roll), ok tuşları (pitch), G (iniş takımı), E (motor), R (reset).
            </p>
        </div>

        <div class="hud-top-center">
            <div class="hud-chip">
                <div class="hud-label">Hız (kn)</div>
                <div class="hud-value" id="hudSpeed">0</div>
            </div>
            <div class="hud-chip">
                <div class="hud-label">Yükseklik (m)</div>
                <div class="hud-value" id="hudAlt">0</div>
            </div>
            <div class="hud-chip">
                <div class="hud-label">Mesafe (km)</div>
                <div class="hud-value" id="hudDist">0.0</div>
            </div>
            <div class="hud-chip">
                <div class="hud-label">Durum</div>
                <div class="hud-value" id="hudStatus">IDLE</div>
            </div>
            <div class="hud-chip">
                <div class="hud-label">Gear</div>
                <div class="hud-value" id="hudGear">DN</div>
            </div>
            <div class="hud-chip">
                <div class="hud-label">Motor</div>
                <div class="hud-value" id="hudEng">ON</div>
            </div>
        </div>

        <div class="hud-top-right">
            <div>FPS: <span id="hudFps">0</span></div>
            <div>Stall: <span id="hudStall">Yok</span></div>
        </div>

        <div class="hud-bottom-center">
            Su-27 tarzı mini flight sim: motor, iniş takımı, pitch ve throttle tamamen sende.
        </div>

        <div class="reticle"></div>

        <div class="center-message" id="startMessage">
            <div class="center-message-title">Pistte Hazır ✈️</div>
            <div class="center-message-sub">
                Gaz vermek için sağ alttaki <b>+</b> tuşuna dokun (veya klavyeden <b>W</b> / <b>↑</b>).<br/>
                Yeterli hızdan sonra burnu kaldırarak (▲) havalan.
            </div>
        </div>

        <div class="game-over-banner" id="gameOverBanner">
            CRASH! İniş çok sert ya da iniş takımı kapalıydı.
            <span>R tuşuna basarak veya sayfayı yenileyerek yeniden başlayabilirsin.</span>
        </div>
    </div>

    <!-- Dokunmatik kontrol padleri -->
    <div class="touch-controls">
        <!-- Sol pad: yaw + roll -->
        <div class="pad-left">
            <div class="ctrl-group">
                <div class="ctrl-row">
                    <button class="ctrl-btn" id="btnYawLeft">◀</button>
                    <button class="ctrl-btn" id="btnYawRight">▶</button>
                </div>
                <div class="ctrl-label">Yön / Roll</div>
            </div>
        </div>

        <!-- Sağ pad: pitch, throttle, gear, engine -->
        <div class="pad-right">
            <div class="ctrl-group">
                <div class="ctrl-row">
                    <button class="ctrl-btn small" id="btnThrottleDown">–</button>
                    <button class="ctrl-btn small" id="btnThrottleUp">+</button>
                </div>
                <div class="ctrl-label">Gaz</div>
                <div class="ctrl-row">
                    <button class="ctrl-btn" id="btnPitchUp">▲</button>
                    <button class="ctrl-btn" id="btnPitchDown">▼</button>
                </div>
                <div class="ctrl-label">Pitch / İrtifa</div>
                <div class="ctrl-row">
                    <button class="ctrl-btn small" id="btnGear">G</button>
                    <button class="ctrl-btn small" id="btnEngine">E</button>
                </div>
                <div class="ctrl-label">İniş Takımı / Motor</div>
            </div>
        </div>
    </div>
</div>

<!-- three.js CDN -->
<script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>

<script>
(function () {
    "use strict";

    const canvas = document.getElementById("gameCanvas");
    const hudSpeed = document.getElementById("hudSpeed");
    const hudAlt   = document.getElementById("hudAlt");
    const hudDist  = document.getElementById("hudDist");
    const hudStatus= document.getElementById("hudStatus");
    const hudFps   = document.getElementById("hudFps");
    const hudStall = document.getElementById("hudStall");
    const hudGear  = document.getElementById("hudGear");
    const hudEng   = document.getElementById("hudEng");
    const startMessage = document.getElementById("startMessage");
    const gameOverBanner = document.getElementById("gameOverBanner");

    const btnYawLeft       = document.getElementById("btnYawLeft");
    const btnYawRight      = document.getElementById("btnYawRight");
    const btnPitchUp       = document.getElementById("btnPitchUp");
    const btnPitchDown     = document.getElementById("btnPitchDown");
    const btnThrottleUp    = document.getElementById("btnThrottleUp");
    const btnThrottleDown  = document.getElementById("btnThrottleDown");
    const btnGear          = document.getElementById("btnGear");
    const btnEngine        = document.getElementById("btnEngine");

    function resize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        if (camera) {
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height, false);
        }
    }
    window.addEventListener("resize", resize);

    // THREE Setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x88aaff, 100, 2800);

    const camera = new THREE.PerspectiveCamera(
        65,
        window.innerWidth / window.innerHeight,
        0.1,
        6000
    );

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    renderer.outputEncoding = THREE.sRGBEncoding;

    // Lights
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x406080, 0.95);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(80, 180, -60);
    scene.add(dirLight);

    // Sky
    const skyGeo = new THREE.SphereGeometry(4000, 24, 16);
    const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
            topColor: { value: new THREE.Color(0x4da0ff) },
            bottomColor: { value: new THREE.Color(0x02101e) },
            offset: { value: 400 },
            exponent: { value: 0.6 },
            time: { value: 0.0 }
        },
        vertexShader: `
            varying float vHeight;
            void main() {
                vHeight = position.y;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            varying float vHeight;

            void main() {
                float h = normalize(vec3(0.0, vHeight + offset, 0.0)).y;
                float t = max(pow(max(h, 0.0), exponent), 0.0);
                gl_FragColor = vec4(mix(bottomColor, topColor, t), 1.0);
            }
        `
    });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(8000, 8000, 32, 32);
    const groundMat = new THREE.MeshStandardMaterial({
        color: 0x113322,
        roughness: 0.95,
        metalness: 0.0,
        vertexColors: true
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    const pos = groundGeo.attributes.position;
    const colors = [];
    for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const z = pos.getZ(i);
        const dist = Math.sqrt(x*x + z*z);
        const factor = 0.2 + 0.2 * Math.random() + 0.2 * Math.max(0, 1 - dist / 4000);
        colors.push(0.06, factor, 0.06);
    }
    groundGeo.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));

    // Runway
    const runwayGeo = new THREE.PlaneGeometry(600, 40);
    const runwayMat = new THREE.MeshStandardMaterial({
        color: 0x333333,
        roughness: 0.8
    });
    const runway = new THREE.Mesh(runwayGeo, runwayMat);
    runway.rotation.x = -Math.PI / 2;
    runway.position.set(0, 0.02, -300);
    scene.add(runway);

    const stripeGeo = new THREE.PlaneGeometry(30, 3);
    const stripeMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    for (let i = 0; i < 10; i++) {
        const stripe = new THREE.Mesh(stripeGeo, stripeMat);
        stripe.rotation.x = -Math.PI / 2;
        stripe.position.set(0, 0.03, -300 + i * 50);
        scene.add(stripe);
    }

    // City
    const cityGroup = new THREE.Group();
    const buildingGeo = new THREE.BoxGeometry(20, 40, 20);
    for (let i = 0; i < 45; i++) {
        const mat = new THREE.MeshStandardMaterial({
            color: new THREE.Color().setHSL(0.55 + Math.random() * 0.05, 0.35, 0.25 + Math.random() * 0.15),
            roughness: 0.85
        });
        const b = new THREE.Mesh(buildingGeo, mat);
        b.scale.y = 1 + Math.random() * 4;
        const side = Math.random() < 0.5 ? -1 : 1;
        const dist = 300 + Math.random() * 2500;
        const offsetX = side * (110 + Math.random() * 450);
        const offsetZ = dist + (Math.random() - 0.5) * 500;
        b.position.set(offsetX, (b.scale.y * 40) / 2, offsetZ);
        cityGroup.add(b);
    }
    scene.add(cityGroup);

    // Clouds
    const cloudGroup = new THREE.Group();
    scene.add(cloudGroup);

    function createCloud(x, y, z) {
        const cloud = new THREE.Group();
        const sphereGeo = new THREE.SphereGeometry(20, 12, 10);
        const mat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
        for (let i = 0; i < 4; i++) {
            const s = new THREE.Mesh(sphereGeo, mat);
            s.position.set(
                (Math.random() - 0.5) * 45,
                (Math.random() - 0.5) * 12,
                (Math.random() - 0.5) * 45
            );
            const scale = 0.7 + Math.random() * 0.8;
            s.scale.set(scale, scale, scale);
            cloud.add(s);
        }
        cloud.position.set(x, y, z);
        cloudGroup.add(cloud);
    }

    for (let i = 0; i < 22; i++) {
        const cx = (Math.random() - 0.5) * 1000;
        const cz = 200 + Math.random() * 2800;
        const cy = 80 + Math.random() * 140;
        createCloud(cx, cy, cz);
    }

    // Su-27 tarzı uçak modeli
    const plane = new THREE.Group();

    // Gövde
    const bodyGeo = new THREE.CylinderGeometry(1.3, 1.3, 24, 16);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x7fb3d5, metalness: 0.55, roughness: 0.3 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.rotation.z = Math.PI / 2;
    plane.add(body);

    // Burun
    const noseGeo = new THREE.ConeGeometry(1.4, 4.5, 16);
    const noseMat = new THREE.MeshStandardMaterial({ color: 0x2e86c1, metalness: 0.6, roughness: 0.3 });
    const nose = new THREE.Mesh(noseGeo, noseMat);
    nose.position.set(12, 0, 0);
    nose.rotation.z = Math.PI / 2;
    plane.add(nose);

    // Kokpit kubbesi
    const canopyGeo = new THREE.SphereGeometry(2.1, 16, 12, 0, Math.PI);
    const canopyMat = new THREE.MeshStandardMaterial({
        color: 0x5dade2,
        metalness: 0.9,
        roughness: 0.1,
        transparent: true,
        opacity: 0.8
    });
    const canopy = new THREE.Mesh(canopyGeo, canopyMat);
    canopy.position.set(4, 1.0, 0);
    canopy.rotation.y = Math.PI / 2;
    plane.add(canopy);

    // Ana kanatlar
    const mainWingGeo = new THREE.BoxGeometry(2, 20, 0.4);
    const mainWingMat = new THREE.MeshStandardMaterial({ color: 0x5dade2, metalness: 0.4, roughness: 0.4 });

    const mainWingLeft = new THREE.Mesh(mainWingGeo, mainWingMat);
    mainWingLeft.position.set(-1, 0, -7);
    mainWingLeft.rotation.y = THREE.MathUtils.degToRad(20);
    mainWingLeft.rotation.z = THREE.MathUtils.degToRad(5);
    plane.add(mainWingLeft);

    const mainWingRight = mainWingLeft.clone();
    mainWingRight.position.z = 7;
    mainWingRight.rotation.y = -THREE.MathUtils.degToRad(20);
    mainWingRight.rotation.z = -THREE.MathUtils.degToRad(5);
    plane.add(mainWingRight);

    // LERX benzeri parçalar
    const lerxGeo = new THREE.BoxGeometry(3, 8, 0.3);
    const lerxLeft = new THREE.Mesh(lerxGeo, mainWingMat);
    lerxLeft.position.set(0, 0.3, -3.5);
    lerxLeft.rotation.y = THREE.MathUtils.degToRad(25);
    plane.add(lerxLeft);

    const lerxRight = lerxLeft.clone();
    lerxRight.position.z = 3.5;
    lerxRight.rotation.y = -THREE.MathUtils.degToRad(25);
    plane.add(lerxRight);

    // İkiz motor gondolları
    const engineGeo = new THREE.CylinderGeometry(0.7, 0.7, 8, 12);
    const engineMat = new THREE.MeshStandardMaterial({ color: 0x566573, metalness: 0.6, roughness: 0.35 });

    const engineLeft = new THREE.Mesh(engineGeo, engineMat);
    engineLeft.rotation.z = Math.PI / 2;
    engineLeft.position.set(-6, -0.6, -2.2);
    plane.add(engineLeft);

    const engineRight = engineLeft.clone();
    engineRight.position.z = 2.2;
    plane.add(engineRight);

    // İkiz dikey kuyruklar
    const vTailGeo = new THREE.BoxGeometry(0.5, 4.5, 2);
    const vTailMat = new THREE.MeshStandardMaterial({ color: 0x2e86c1, metalness: 0.4, roughness: 0.4 });

    const vTailLeft = new THREE.Mesh(vTailGeo, vTailMat);
    vTailLeft.position.set(-8, 2.0, -2.2);
    vTailLeft.rotation.z = THREE.MathUtils.degToRad(18);
    plane.add(vTailLeft);

    const vTailRight = vTailLeft.clone();
    vTailRight.position.z = 2.2;
    vTailRight.rotation.z = -THREE.MathUtils.degToRad(18);
    plane.add(vTailRight);

    // Yatay kuyruklar
    const hTailGeo = new THREE.BoxGeometry(0.6, 5.5, 0.25);
    const hTailMat = new THREE.MeshStandardMaterial({ color: 0x7fb3d5, metalness: 0.35, roughness: 0.4 });

    const hTailLeft = new THREE.Mesh(hTailGeo, hTailMat);
    hTailLeft.position.set(-8.5, -0.3, -3.5);
    hTailLeft.rotation.y = THREE.MathUtils.degToRad(15);
    plane.add(hTailLeft);

    const hTailRight = hTailLeft.clone();
    hTailRight.position.z = 3.5;
    hTailRight.rotation.y = -THREE.MathUtils.degToRad(15);
    plane.add(hTailRight);

    // Basit iniş takımları (gövde altında üç ayak)
    const gearGroup = new THREE.Group();
    const gearLegGeo = new THREE.CylinderGeometry(0.15, 0.15, 1.0, 8);
    const wheelGeo = new THREE.TorusGeometry(0.25, 0.08, 8, 16);

    function createGearLeg(x, z) {
        const legMat = new THREE.MeshStandardMaterial({ color: 0xf0f3f4, roughness: 0.5 });
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x17202a, roughness: 0.7 });

        const leg = new THREE.Mesh(gearLegGeo, legMat);
        leg.position.set(x, -1.2, z);

        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(x, -1.7, z);

        const unit = new THREE.Group();
        unit.add(leg);
        unit.add(wheel);

        gearGroup.add(unit);
    }

    createGearLeg(0, 0);     // burun iniş takımı
    createGearLeg(-4, -1.5); // sol arka
    createGearLeg(-4, 1.5);  // sağ arka
    plane.add(gearGroup);

    plane.position.set(0, 1.5, 0); // pistin üstünde
    plane.rotation.set(0, 0, 0);
    scene.add(plane);

    camera.position.set(-18, 6, 28);
    camera.lookAt(plane.position);

    // INPUT
    const keys = {};
    const input = {
        yawLeft: false,
        yawRight: false,
        pitchUp: false,
        pitchDown: false,
        throttleUp: false,
        throttleDown: false
    };

    let engineOn = true;
    let gearDown = true;

    function updateGearHud() {
        hudGear.textContent = gearDown ? "DN" : "UP";
    }
    function updateEngineHud() {
        hudEng.textContent = engineOn ? "ON" : "OFF";
    }

    function toggleGear() {
        gearDown = !gearDown;
        gearGroup.visible = gearDown;
        updateGearHud();
    }

    function toggleEngine() {
        engineOn = !engineOn;
        updateEngineHud();
    }

    window.addEventListener("keydown", e => {
        keys[e.key] = true;
        if (e.key === "w" || e.key === "ArrowUp") input.throttleUp = true;
        if (e.key === "s" || e.key === "ArrowDown") input.throttleDown = true;
        if (e.key === "a" || e.key === "ArrowLeft") input.yawLeft = true;
        if (e.key === "d" || e.key === "ArrowRight") input.yawRight = true;
        if (e.key === "g" || e.key === "G") toggleGear();
        if (e.key === "e" || e.key === "E") toggleEngine();
        if (e.key === "r" || e.key === "R") resetGame();
    });

    window.addEventListener("keyup", e => {
        keys[e.key] = false;
        if (e.key === "w" || e.key === "ArrowUp") input.throttleUp = false;
        if (e.key === "s" || e.key === "ArrowDown") input.throttleDown = false;
        if (e.key === "a" || e.key === "ArrowLeft") input.yawLeft = false;
        if (e.key === "d" || e.key === "ArrowRight") input.yawRight = false;
    });

    function bindHoldButton(btn, prop) {
        const on = (ev) => { ev.preventDefault(); input[prop] = true; };
        const off= (ev) => { ev.preventDefault(); input[prop] = false; };
        ["touchstart","mousedown"].forEach(ev => btn.addEventListener(ev, on));
        ["touchend","touchcancel","mouseup","mouseleave"].forEach(ev => btn.addEventListener(ev, off));
    }

    bindHoldButton(btnYawLeft,      "yawLeft");
    bindHoldButton(btnYawRight,     "yawRight");
    bindHoldButton(btnPitchUp,      "pitchUp");
    bindHoldButton(btnPitchDown,    "pitchDown");
    bindHoldButton(btnThrottleUp,   "throttleUp");
    bindHoldButton(btnThrottleDown, "throttleDown");

    // Toggle butonları (G/E)
    function bindToggleButton(btn, callback) {
        btn.addEventListener("click", (ev) => { ev.preventDefault(); callback(); });
        btn.addEventListener("touchstart", (ev) => { ev.preventDefault(); callback(); });
    }
    bindToggleButton(btnGear, toggleGear);
    bindToggleButton(btnEngine, toggleEngine);

    // FLIGHT STATE
    let throttle = 0;             // 0..1
    let speed = 0;                // m/s
    const maxSpeed = 120;         // m/s (~233kn)
    let distanceTravelled = 0;
    let gameOver = false;
    let hasStarted = false;

    let lastAlt = plane.position.y;
    let isStalling = false;

    const gravity = 9.81;
    const stallSpeed = 35;        // m/s
    const liftCoeff = 1.8;        // daha sakin lift
    const baseDragCoeff = 0.02;
    const gearDragExtra = 0.015;

    const clock = new THREE.Clock();

    let fpsAccum = 0;
    let fpsFrames = 0;
    let fpsDisplay = 0;
    let fpsTimer = 0;

    function resetGame() {
        throttle = 0;
        speed = 0;
        distanceTravelled = 0;
        gameOver = false;
        hasStarted = false;
        isStalling = false;
        engineOn = true;
        gearDown = true;
        gearGroup.visible = true;
        updateGearHud();
        updateEngineHud();

        plane.position.set(0, 1.5, 0);
        plane.rotation.set(0, 0, 0);
        camera.position.set(-18, 6, 28);
        camera.lookAt(plane.position);
        hudStatus.textContent = "IDLE";
        hudSpeed.textContent = "0";
        hudAlt.textContent = "1";
        hudDist.textContent = "0.0";
        hudStall.textContent = "Yok";
        gameOverBanner.style.display = "none";
        if (startMessage) {
            startMessage.classList.remove("fade-out");
            startMessage.style.opacity = "1";
        }
        clock.getDelta();
    }

    resetGame();
    resize();

    function updateFlight(dt) {
        if (gameOver) return;

        dt = Math.min(dt, 0.04);

        // Motor kapalıysa throttle yavaşça sıfıra iner
        if (!engineOn) {
            throttle -= 0.6 * dt;
        }

        const throttleChange = 0.45 * dt;
        if (engineOn) {
            if (input.throttleUp) {
                throttle += throttleChange;
                hasStarted = true;
            }
            if (input.throttleDown) {
                throttle -= throttleChange;
            }
        }
        throttle = THREE.MathUtils.clamp(throttle, 0, 1);

        const targetSpeed = maxSpeed * throttle;
        const accelToTarget = (targetSpeed - speed) * (0.75 * dt);
        speed += accelToTarget;
        if (speed < 0.1) speed = 0;

        const yawRate   = THREE.MathUtils.degToRad(38);
        const pitchRate = THREE.MathUtils.degToRad(24);
        const rollRate  = THREE.MathUtils.degToRad(33);

        if (speed > 5) {
            if (input.yawLeft && !input.yawRight) {
                plane.rotation.y += yawRate * dt;
                plane.rotation.z += rollRate * dt * 0.55;
            } else if (input.yawRight && !input.yawLeft) {
                plane.rotation.y -= yawRate * dt;
                plane.rotation.z -= rollRate * dt * 0.55;
            } else {
                plane.rotation.z *= (1 - 1.8 * dt);
            }

            if (input.pitchUp && !input.pitchDown) {
                plane.rotation.x -= pitchRate * dt;
            } else if (input.pitchDown && !input.pitchUp) {
                plane.rotation.x += pitchRate * dt;
            } else {
                plane.rotation.x *= (1 - 1.2 * dt);
            }
        } else {
            plane.rotation.z *= (1 - 2.0 * dt);
            plane.rotation.x *= (1 - 1.5 * dt);
        }

        plane.rotation.x = THREE.MathUtils.clamp(plane.rotation.x, -0.5, 0.45);
        plane.rotation.z = THREE.MathUtils.clamp(plane.rotation.z, -0.9, 0.9);

        const forward = new THREE.Vector3(0,0,-1).applyEuler(plane.rotation).normalize();

        // Basitleştirilmiş aerodinamik
        const speedSq = speed * speed;

        const dragCoeff = baseDragCoeff + (gearDown ? gearDragExtra : 0);
        const drag = dragCoeff * speedSq;
        const dragVec = forward.clone().multiplyScalar(-drag);

        // Açıya bağlı lift (pitch çekmezsen çok az)
        const aoa = THREE.MathUtils.clamp(-plane.rotation.x, -0.5, 0.5);
        let lift = 0;
        if (speed > stallSpeed && aoa > 0) {
            const aoaFactor = aoa / 0.5; // 0..1
            lift = liftCoeff * speedSq * aoaFactor;
        } else if (speed < stallSpeed * 0.8) {
            lift = -15; // sert stall değil ama aşağı çeken kuvvet
        }

        const liftVec = new THREE.Vector3(0, lift, 0);
        const gravityVec = new THREE.Vector3(0, -gravity * 18, 0);

        const thrust = engineOn ? throttle * 150 : 0;
        const thrustVec = forward.clone().multiplyScalar(thrust);

        const accel = new THREE.Vector3();
        accel.add(thrustVec);
        accel.add(dragVec);
        accel.add(liftVec);
        accel.add(gravityVec);

        let velForward = forward.clone().multiplyScalar(speed);
        velForward.add(accel.multiplyScalar(dt));

        const newSpeed = velForward.length();
        speed = THREE.MathUtils.clamp(newSpeed, 0, maxSpeed);

        if (speed > 0.001) {
            velForward.normalize().multiplyScalar(speed);
        } else {
            velForward.set(0,0,0);
        }

        const move = velForward.clone().multiplyScalar(dt);
        plane.position.add(move);
        distanceTravelled += move.length();

        const groundHeight = 0;
        const gearHeight = 1.5;
        const altitude = plane.position.y - groundHeight;
        const verticalSpeed = (plane.position.y - lastAlt) / dt;
        lastAlt = plane.position.y;

        // Ground contact
        if (plane.position.y < groundHeight + gearHeight) {
            plane.position.y = groundHeight + gearHeight;

            if (!gearDown && speed > 5) {
                // İniş takımı kapalıyken yere vurursan direkt CRASH
                triggerGameOver();
            } else {
                // Yumuşak iniş kontrolü
                if (Math.abs(verticalSpeed) > 10 || speed > 22) {
                    triggerGameOver();
                } else {
                    // Pistte rollout – sürtünme ile yavaşla
                    speed *= (1 - 1.8 * dt);
                }
            }
        }

        if (plane.position.y > 900) {
            plane.position.y = 900;
        }

        // Kamera
        const camOffset = new THREE.Vector3(0, 7, 27);
        camOffset.applyEuler(plane.rotation);
        const desiredCamPos = plane.position.clone().add(camOffset);
        camera.position.lerp(desiredCamPos, 0.12);
        const lookAtPoint = plane.position.clone().add(forward.clone().multiplyScalar(45));
        camera.lookAt(lookAtPoint);

        cloudGroup.children.forEach(cloud => {
            cloud.position.z -= 12 * dt;
            if (cloud.position.z < -800) {
                cloud.position.z = 2800 + Math.random() * 600;
                cloud.position.x = (Math.random() - 0.5) * 1000;
                cloud.position.y = 80 + Math.random() * 150;
            }
        });

        const speedKnots = speed * 1.94384;
        hudSpeed.textContent = speedKnots.toFixed(0);
        hudAlt.textContent = altitude.toFixed(0);
        hudDist.textContent = (distanceTravelled / 1000).toFixed(1);

        if (!hasStarted && speed < 2) {
            hudStatus.textContent = "IDLE";
        } else if (speed < stallSpeed) {
            hudStatus.textContent = "STALL/OFF";
        } else if (speed < stallSpeed + 15) {
            hudStatus.textContent = "ROTATE";
        } else if (speed < 80) {
            hudStatus.textContent = "CLIMB";
        } else {
            hudStatus.textContent = "CRUISE";
        }

        isStalling = speed < stallSpeed && altitude > 5 && throttle < 0.7;
        hudStall.textContent = isStalling ? "Evet" : "Yok";

        if (hasStarted && startMessage && startMessage.style.opacity !== "0") {
            startMessage.classList.add("fade-out");
        }
    }

    function triggerGameOver() {
        if (gameOver) return;
        gameOver = true;
        hudStatus.textContent = "CRASH";
        gameOverBanner.style.display = "block";
    }

    function renderLoop() {
        const dt = clock.getDelta();
        updateFlight(dt);

        const fps = 1 / Math.max(dt, 0.00001);
        fpsAccum += fps;
        fpsFrames++;
        fpsTimer += dt;
        if (fpsTimer >= 0.5) {
            fpsDisplay = fpsAccum / fpsFrames;
            fpsAccum = 0;
            fpsFrames = 0;
            fpsTimer = 0;
            hudFps.textContent = fpsDisplay.toFixed(0);
        }

        renderer.render(scene, camera);
        requestAnimationFrame(renderLoop);
    }

    renderLoop();
})();
</script>
</body>
</html>
