<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8" />
    <title>SkyRunner 3D - Cockpit Day Final V2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* GÜNDÜZ GÖKYÜZÜ ARKAPLANI */
            background: linear-gradient(to bottom, #aee3ff 0%, #e0f3ff 45%, #bcd7ff 100%);
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: transparent;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* HUD */
        .hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        #hud-info {
            position: absolute;
            top: 8px;
            left: 8px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.6);
            color: #0fef8f;
            font-size: 11px;
            letter-spacing: 0.08em;
            pointer-events: none;
            text-shadow: 0 0 4px #000;
        }

        #hud-sub {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.6);
            color: #e5e7ff;
            font-size: 11px;
            pointer-events: none;
            text-shadow: 0 0 4px #000;
        }

        #hud-terrain {
            position: absolute;
            top: 42px;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 14px;
            border-radius: 999px;
            border: 1px solid rgba(248,113,113,0.9);
            background: rgba(127,29,29,0.75);
            color: #fee2e2;
            font-size: 11px;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            pointer-events: none;
            opacity: 0;
            text-shadow: 0 0 6px #000;
        }

        #hud-center {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 40px;
            height: 40px;
            margin-left: -20px;
            margin-top: -20px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 8px #000;
            pointer-events: none;
        }

        #hud-center::after {
            content: "";
            position: absolute;
            left: 50%;
            top: 50%;
            width: 4px;
            height: 4px;
            margin-left: -2px;
            margin-top: -2px;
            border-radius: 50%;
            background: #0fef8f;
        }

        .btn {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 999px;
            background:
                radial-gradient(circle at 25% 20%, #ffffffdd, #1f2937 55%, #020617 100%);
            box-shadow:
                0 0 0 1px #ffffff55,
                0 0 10px rgba(15,23,42,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #e5e7eb;
            font-size: 11px;
            text-align: center;
            pointer-events: auto;
            user-select: none;
            backdrop-filter: blur(6px);
        }

        .btn:active {
            transform: scale(0.95);
            box-shadow:
                0 0 0 1px #0fef8f99,
                0 0 18px #0fef8f55;
        }

        /* Kontroller */

        /* Sol: THR */
        .btn-thr-up {
            top: 35%;
            left: 12px;
        }
        .btn-thr-down {
            top: calc(35% + 90px);
            left: 12px;
        }

        /* Sağ: PITCH */
        .btn-pitch-up {
            top: 35%;
            right: 12px;
        }
        .btn-pitch-down {
            top: calc(35% + 90px);
            right: 12px;
        }

        /* Alt orta: YAW */
        .btn-yaw-left {
            bottom: 80px;
            left: 50%;
            transform: translateX(-110px);
            width: 70px;
            height: 70px;
        }

        .btn-yaw-right {
            bottom: 80px;
            left: 50%;
            transform: translateX(40px);
            width: 70px;
            height: 70px;
        }

        /* Motor / Gear butonları */
        .btn-eng-on {
            top: 90px;
            left: 50%;
            transform: translateX(-135px);
            width: 70px;
            height: 70px;
            font-size: 10px;
        }

        .btn-eng-off {
            top: 90px;
            left: 50%;
            transform: translateX(-35px);
            width: 70px;
            height: 70px;
            font-size: 10px;
        }

        .btn-gear {
            top: 90px;
            left: 50%;
            transform: translateX(65px);
            width: 70px;
            height: 70px;
            font-size: 10px;
        }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="game"></canvas>

    <div class="hud">
        <div id="hud-info">SPD 0 | ALT 0 | THR 0%</div>
        <div id="hud-sub">SKYRUNNER • COCKPIT DAY VIEW</div>
        <div id="hud-terrain">TERRAIN</div>
        <div id="hud-center"></div>

        <!-- Sol - Motor (ince ayar) -->
        <div class="btn btn-thr-up">THR<br>+</div>
        <div class="btn btn-thr-down">THR<br>-</div>

        <!-- Sağ - Pitch -->
        <div class="btn btn-pitch-up">NOSE<br>UP</div>
        <div class="btn btn-pitch-down">NOSE<br>DOWN</div>

        <!-- Orta alt - Yaw -->
        <div class="btn btn-yaw-left">YAW<br>◀</div>
        <div class="btn btn-yaw-right">YAW<br>▶</div>

        <!-- Motor / Gear -->
        <div class="btn btn-eng-on">ENG<br>ON</div>
        <div class="btn btn-eng-off">ENG<br>OFF</div>
        <div class="btn btn-gear">GEAR</div>
    </div>
</div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
(() => {
    const container = document.getElementById('game-container');
    const canvas = document.getElementById('game');

    const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true
    });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(container.clientWidth, container.clientHeight);

    // GÜNDÜZ GÖKYÜZÜ RENGİ
    renderer.setClearColor(0xaee3ff, 1);

    const scene = new THREE.Scene();
    // GÜNDÜZ SİSİ
    scene.fog = new THREE.FogExp2(0xcfe8ff, 0.00035);

    const camera = new THREE.PerspectiveCamera(
        60,
        container.clientWidth / container.clientHeight,
        0.1,
        8000
    );

    // Işıklar (daha parlak gündüz)
    const hemi = new THREE.HemisphereLight(0xdbeafe, 0x2f3b2f, 1.0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.25);
    dir.position.set(200, 400, 120);
    dir.castShadow = true;
    scene.add(dir);

    // "Güneş"
    const sunGeo = new THREE.SphereGeometry(60, 32, 32);
    const sunMat = new THREE.MeshBasicMaterial({ color: 0xfff7d6 });
    const sun = new THREE.Mesh(sunGeo, sunMat);
    sun.position.set(-800, 900, -1500);
    scene.add(sun);

    // Zemin (daha açık yeşil)
    const groundGeo = new THREE.PlaneGeometry(6000, 6000, 32, 32);
    const groundMat = new THREE.MeshStandardMaterial({
        color: 0x3b7f3b,
        roughness: 0.9,
        metalness: 0.0
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    // Pist
    const runwayGeo = new THREE.PlaneGeometry(1600, 60);
    const runwayMat = new THREE.MeshStandardMaterial({
        color: 0x2f343c,
        roughness: 0.8,
        metalness: 0.2
    });
    const runway = new THREE.Mesh(runwayGeo, runwayMat);
    runway.rotation.x = -Math.PI / 2;
    runway.position.set(0, 0.02, 0);
    runway.receiveShadow = true;
    scene.add(runway);

    // Pist çizgileri (runway ekseni Z)
    const stripeMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.8,
        metalness: 0.1
    });
    for (let i = -750; i <= 750; i += 80) {
        const stripeGeo = new THREE.PlaneGeometry(18, 3);
        const stripe = new THREE.Mesh(stripeGeo, stripeMat);
        stripe.rotation.x = -Math.PI / 2;
        stripe.position.set(0, 0.03, i);
        scene.add(stripe);
    }

    // Yan kenar çizgileri
    const edgeMat = new THREE.MeshStandardMaterial({
        color: 0xfafafa,
        roughness: 0.9,
        metalness: 0.0
    });
    const edgeGeo = new THREE.PlaneGeometry(1600, 1.5);
    const leftEdge = new THREE.Mesh(edgeGeo, edgeMat);
    const rightEdge = new THREE.Mesh(edgeGeo, edgeMat);
    leftEdge.rotation.x = -Math.PI / 2;
    rightEdge.rotation.x = -Math.PI / 2;
    leftEdge.position.set(-27, 0.03, 0);
    rightEdge.position.set(27, 0.03, 0);
    scene.add(leftEdge, rightEdge);

    // Bulutlar (gündüz, hafif daha opak)
    const clouds = [];
    const cloudMat = new THREE.MeshLambertMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.9
    });
    for (let i = 0; i < 25; i++) {
        const cg = new THREE.SphereGeometry(THREE.MathUtils.randFloat(40, 80), 12, 12);
        const cm = new THREE.Mesh(cg, cloudMat);
        const radius = THREE.MathUtils.randFloat(400, 1500);
        const angle = Math.random() * Math.PI * 2;
        cm.position.set(
            Math.cos(angle) * radius,
            THREE.MathUtils.randFloat(160, 260),
            Math.sin(angle) * radius
        );
        cm.scale.set(
            THREE.MathUtils.randFloat(1.2, 1.8),
            THREE.MathUtils.randFloat(0.6, 1.2),
            THREE.MathUtils.randFloat(1.2, 1.8)
        );
        scene.add(cm);
        clouds.push(cm);
    }

    // -------------------------------------------------------------------------
    // UÇAK MODELİ + KOKPİT
    // -------------------------------------------------------------------------

    const jet = new THREE.Group();

    let leftWing, rightWing, tail;
    let flapL, flapR, elevonL, elevonR;
    let rudderL, rudderR;
    let canardL, canardR;
    let noseWheel, mainWheelL, mainWheelR, gearStrutN, gearStrutL, gearStrutR;
    let leftNavLight, rightNavLight, tailNavLight;
    let glowL, glowR;
    let cockpitRig;
    let controlStick;
    const cockpitScreens = [];

    // Malzemeler
    const hullMetalMaterial = new THREE.MeshStandardMaterial({
        color: 0x1f2937,
        metalness: 0.9,
        roughness: 0.28
    });
    const accentBlueMaterial = new THREE.MeshStandardMaterial({
        color: 0x2563eb,
        metalness: 0.92,
        roughness: 0.25
    });
    const accentDarkBlueMaterial = new THREE.MeshStandardMaterial({
        color: 0x1d4ed8,
        metalness: 0.92,
        roughness: 0.35
    });
    const engineMetalMaterial = new THREE.MeshStandardMaterial({
        color: 0x020617,
        metalness: 0.95,
        roughness: 0.4
    });
    const wheelRubberMaterial = new THREE.MeshStandardMaterial({
        color: 0x020617,
        metalness: 0.2,
        roughness: 0.9
    });
    const strutMetalMaterial = new THREE.MeshStandardMaterial({
        color: 0xe5e7eb,
        metalness: 0.9,
        roughness: 0.3
    });
    const missileBodyMaterial = new THREE.MeshStandardMaterial({
        color: 0xf9fafb,
        metalness: 0.4,
        roughness: 0.5
    });
    const missileNoseMaterial = new THREE.MeshStandardMaterial({
        color: 0x9ca3af,
        metalness: 0.8,
        roughness: 0.2
    });
    const tankMaterial = new THREE.MeshStandardMaterial({
        color: 0x0f172a,
        metalness: 0.9,
        roughness: 0.3
    });
    const panelMaterial = new THREE.MeshStandardMaterial({
        color: 0x111827,
        metalness: 0.7,
        roughness: 0.5
    });
    const canopyOuterMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x93c5fd,
        roughness: 0.08,
        metalness: 0.15,
        transparent: true,
        opacity: 0.14,  // DAHA ŞEFFAF CAM
        reflectivity: 1.0,
        clearcoat: 0.9
    });
    const canopyFrameMaterial = new THREE.MeshStandardMaterial({
        color: 0x020617,
        metalness: 0.9,
        roughness: 0.35
    });
    // ÖNDEKİ SİYAH ŞERİT İÇİN CAM MALZEME
    const frameGlassMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x9ca3af,
        roughness: 0.05,
        metalness: 0.0,
        transparent: true,
        opacity: 0.10,
        reflectivity: 0.6,
        clearcoat: 0.4
    });
    const navRedMaterial = new THREE.MeshBasicMaterial({
        color: 0xef4444,
        transparent: true,
        opacity: 0.9
    });
    const navGreenMaterial = new THREE.MeshBasicMaterial({
        color: 0x22c55e,
        transparent: true,
        opacity: 0.9
    });
    const navWhiteMaterial = new THREE.MeshBasicMaterial({
        color: 0xf9fafb,
        transparent: true,
        opacity: 0.9
    });
    const afterburnerMat = new THREE.MeshBasicMaterial({
        color: 0x60a5fa,
        transparent: true,
        opacity: 0.0
    });

    // Gövde
    const frontHullGeo = new THREE.CylinderGeometry(0.7, 1.0, 8.0, 24, 1, false);
    const frontHull = new THREE.Mesh(frontHullGeo, hullMetalMaterial);
    frontHull.rotation.z = Math.PI / 2;
    frontHull.position.set(4.0, 0.1, 0);
    frontHull.castShadow = true;
    jet.add(frontHull);

    const midHullGeo = new THREE.CylinderGeometry(1.0, 1.0, 8.5, 26, 1, false);
    const midHull = new THREE.Mesh(midHullGeo, hullMetalMaterial);
    midHull.rotation.z = Math.PI / 2;
    midHull.position.set(-0.2, 0.0, 0);
    midHull.castShadow = true;
    jet.add(midHull);

    const rearHullGeo = new THREE.CylinderGeometry(0.9, 1.0, 7.0, 22, 1, false);
    const rearHull = new THREE.Mesh(rearHullGeo, hullMetalMaterial);
    rearHull.rotation.z = Math.PI / 2;
    rearHull.position.set(-5.5, -0.1, 0);
    rearHull.castShadow = true;
    jet.add(rearHull);

    for (let i = -6; i <= 4; i += 2) {
        const spineGeo = new THREE.BoxGeometry(0.7, 0.12, 0.6);
        const spine = new THREE.Mesh(spineGeo, panelMaterial);
        spine.position.set(i, 0.8, 0);
        spine.castShadow = true;
        jet.add(spine);
    }

    // Burun
    const noseGeo = new THREE.ConeGeometry(1.05, 3.5, 28);
    const nose = new THREE.Mesh(noseGeo, accentBlueMaterial);
    nose.position.set(7.8, 0.0, 0);
    nose.rotation.z = Math.PI / 2;
    nose.castShadow = true;
    jet.add(nose);

    const noseTipGeo = new THREE.ConeGeometry(0.6, 1.5, 24);
    const noseTip = new THREE.Mesh(noseTipGeo, engineMetalMaterial);
    noseTip.position.set(9.3, 0, 0);
    noseTip.rotation.z = Math.PI / 2;
    noseTip.castShadow = true;
    jet.add(noseTip);

    // Canopy (kokpit camı)
    const canopyGeo = new THREE.SphereGeometry(1.2, 28, 18, 0, Math.PI * 2, 0, Math.PI / 1.8);
    const canopy = new THREE.Mesh(canopyGeo, canopyOuterMaterial);
    canopy.position.set(2.3, 0.85, 0);
    canopy.rotation.z = Math.PI / 2;
    canopy.castShadow = true;
    jet.add(canopy);

    const canopyFrameGeo = new THREE.TorusGeometry(1.18, 0.06, 10, 30);
    const canopyFrame = new THREE.Mesh(canopyFrameGeo, canopyFrameMaterial);
    canopyFrame.position.set(2.3, 0.86, 0);
    canopyFrame.rotation.y = Math.PI / 2;
    canopyFrame.castShadow = true;
    jet.add(canopyFrame);

    const frontFrameGeo = new THREE.BoxGeometry(0.1, 0.9, 1.6);
    // ÖNDEKİ SİYAH ÇERÇEVE ARTIK CAM
    const frontFrame = new THREE.Mesh(frontFrameGeo, frameGlassMaterial);
    frontFrame.position.set(3.4, 0.7, 0);
    jet.add(frontFrame);

    // Kanatlar
    const mainWingGeo = new THREE.BoxGeometry(8.4, 0.18, 2.6);
    const flapGeo = new THREE.BoxGeometry(3.4, 0.16, 0.8);
    const elevonGeo = new THREE.BoxGeometry(2.0, 0.14, 0.7);

    leftWing = new THREE.Mesh(mainWingGeo, accentDarkBlueMaterial);
    leftWing.position.set(-0.6, 0.0, -3.2);
    leftWing.rotation.x = THREE.MathUtils.degToRad(3);
    leftWing.rotation.y = THREE.MathUtils.degToRad(2);
    leftWing.castShadow = true;
    jet.add(leftWing);

    rightWing = new THREE.Mesh(mainWingGeo, accentDarkBlueMaterial);
    rightWing.position.set(-0.6, 0.0, 3.2);
    rightWing.rotation.x = THREE.MathUtils.degToRad(-3);
    rightWing.rotation.y = THREE.MathUtils.degToRad(-2);
    rightWing.castShadow = true;
    jet.add(rightWing);

    flapL = new THREE.Mesh(flapGeo, hullMetalMaterial);
    flapL.position.set(-1.0, -0.05, -3.1);
    flapL.castShadow = true;
    jet.add(flapL);

    flapR = new THREE.Mesh(flapGeo, hullMetalMaterial);
    flapR.position.set(-1.0, -0.05, 3.1);
    flapR.castShadow = true;
    jet.add(flapR);

    elevonL = new THREE.Mesh(elevonGeo, accentBlueMaterial);
    elevonL.position.set(-3.9, -0.03, -3.0);
    elevonL.castShadow = true;
    jet.add(elevonL);

    elevonR = new THREE.Mesh(elevonGeo, accentBlueMaterial);
    elevonR.position.set(-3.9, -0.03, 3.0);
    elevonR.castShadow = true;
    jet.add(elevonR);

    // Kuyruk
    const tailWingGeo = new THREE.BoxGeometry(4.0, 0.16, 1.6);
    tail = new THREE.Mesh(tailWingGeo, accentBlueMaterial);
    tail.position.set(-6.2, 0.35, 0);
    tail.rotation.x = THREE.MathUtils.degToRad(5);
    tail.castShadow = true;
    jet.add(tail);

    const vTailGeo = new THREE.BoxGeometry(0.22, 2.2, 1.1);
    rudderL = new THREE.Mesh(vTailGeo, accentDarkBlueMaterial);
    rudderR = new THREE.Mesh(vTailGeo, accentDarkBlueMaterial);
    rudderL.position.set(-6.4, 1.1, -0.9);
    rudderR.position.set(-6.4, 1.1, 0.9);
    rudderL.rotation.x = THREE.MathUtils.degToRad(14);
    rudderR.rotation.x = THREE.MathUtils.degToRad(14);
    rudderL.castShadow = true;
    rudderR.castShadow = true;
    jet.add(rudderL, rudderR);

    // Canard
    const canardGeo = new THREE.BoxGeometry(2.4, 0.12, 0.8);
    canardL = new THREE.Mesh(canardGeo, accentBlueMaterial);
    canardR = new THREE.Mesh(canardGeo, accentBlueMaterial);
    canardL.position.set(3.8, 0.4, -1.6);
    canardR.position.set(3.8, 0.4, 1.6);
    canardL.rotation.y = THREE.MathUtils.degToRad(6);
    canardR.rotation.y = THREE.MathUtils.degToRad(-6);
    canardL.castShadow = true;
    canardR.castShadow = true;
    jet.add(canardL, canardR);

    // Çift motor + afterburner
    const engineGeo = new THREE.CylinderGeometry(0.6, 0.9, 2.6, 20);
    const engineL = new THREE.Mesh(engineGeo, engineMetalMaterial);
    const engineR = new THREE.Mesh(engineGeo, engineMetalMaterial);
    engineL.rotation.z = Math.PI / 2;
    engineR.rotation.z = Math.PI / 2;
    engineL.position.set(-7.5, -0.25, -0.9);
    engineR.position.set(-7.5, -0.25, 0.9);
    engineL.castShadow = true;
    engineR.castShadow = true;
    jet.add(engineL, engineR);

    const glowGeo = new THREE.SphereGeometry(0.95, 20, 20);
    glowL = new THREE.Mesh(glowGeo, afterburnerMat);
    glowR = new THREE.Mesh(glowGeo, afterburnerMat);
    glowL.position.set(-8.9, -0.25, -0.9);
    glowR.position.set(-8.9, -0.25, 0.9);
    jet.add(glowL, glowR);

    // Landing gear
    const noseStrutGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.4, 10);
    gearStrutN = new THREE.Mesh(noseStrutGeo, strutMetalMaterial);
    gearStrutN.rotation.z = Math.PI / 2;
    gearStrutN.position.set(4.2, -0.9, 0);
    gearStrutN.castShadow = true;
    jet.add(gearStrutN);

    const noseWheelGeo = new THREE.TorusGeometry(0.32, 0.12, 10, 20);
    noseWheel = new THREE.Mesh(noseWheelGeo, wheelRubberMaterial);
    noseWheel.rotation.y = Math.PI / 2;
    noseWheel.position.set(4.9, -1.1, 0);
    noseWheel.castShadow = true;
    jet.add(noseWheel);

    const mainStrutGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.6, 10);
    gearStrutL = new THREE.Mesh(mainStrutGeo, strutMetalMaterial);
    gearStrutR = new THREE.Mesh(mainStrutGeo, strutMetalMaterial);
    gearStrutL.rotation.z = Math.PI / 2;
    gearStrutR.rotation.z = Math.PI / 2;
    gearStrutL.position.set(-1.0, -0.95, -1.8);
    gearStrutR.position.set(-1.0, -0.95, 1.8);
    gearStrutL.castShadow = true;
    gearStrutR.castShadow = true;
    jet.add(gearStrutL, gearStrutR);

    const mainWheelGeo = new THREE.TorusGeometry(0.45, 0.16, 12, 24);
    mainWheelL = new THREE.Mesh(mainWheelGeo, wheelRubberMaterial);
    mainWheelR = new THREE.Mesh(mainWheelGeo, wheelRubberMaterial);
    mainWheelL.rotation.y = Math.PI / 2;
    mainWheelR.rotation.y = Math.PI / 2;
    mainWheelL.position.set(-1.9, -1.2, -1.8);
    mainWheelR.position.set(-1.9, -1.2, 1.8);
    mainWheelL.castShadow = true;
    mainWheelR.castShadow = true;
    jet.add(mainWheelL, mainWheelR);

    // Yakıt tankı
    const tankGeo = new THREE.CapsuleGeometry(0.5, 3.6, 8, 16);
    const tank = new THREE.Mesh(tankGeo, tankMaterial);
    tank.position.set(-0.8, -0.8, 0);
    tank.rotation.z = Math.PI / 2;
    tank.castShadow = true;
    jet.add(tank);

    // Füzeler
    const missileBodyGeo = new THREE.CylinderGeometry(0.18, 0.2, 2.4, 12);
    const missileNoseGeo = new THREE.ConeGeometry(0.19, 0.7, 12);
    const missileFinGeo = new THREE.BoxGeometry(0.02, 0.4, 0.25);

    function createMissile(offsetZ) {
        const missile = new THREE.Group();
        const body = new THREE.Mesh(missileBodyGeo, missileBodyMaterial);
        body.rotation.z = Math.PI / 2;
        body.castShadow = true;
        missile.add(body);

        const nose = new THREE.Mesh(missileNoseGeo, missileNoseMaterial);
        nose.position.set(1.3, 0, 0);
        nose.rotation.z = Math.PI / 2;
        nose.castShadow = true;
        missile.add(nose);

        for (let i = 0; i < 4; i++) {
            const fin = new THREE.Mesh(missileFinGeo, panelMaterial);
            const angle = (Math.PI / 2) * i;
            const r = 0.25;
            fin.position.set(-0.2, Math.cos(angle) * r, Math.sin(angle) * r);
            fin.castShadow = true;
            missile.add(fin);
        }

        missile.position.set(-1.0, -0.4, offsetZ);
        return missile;
    }

    const missileL1 = createMissile(-3.6);
    const missileR1 = createMissile(3.6);
    const missileL2 = createMissile(-2.5);
    const missileR2 = createMissile(2.5);
    jet.add(missileL1, missileR1, missileL2, missileR2);

    // Nav ışıkları
    const navLightGeo = new THREE.SphereGeometry(0.22, 10, 10);
    leftNavLight = new THREE.Mesh(navLightGeo, navRedMaterial);
    rightNavLight = new THREE.Mesh(navLightGeo, navGreenMaterial);
    tailNavLight = new THREE.Mesh(navLightGeo, navWhiteMaterial);
    leftNavLight.position.set(-4.5, 0.1, -4.1);
    rightNavLight.position.set(-4.5, 0.1, 4.1);
    tailNavLight.position.set(-7.4, 0.6, 0);
    jet.add(leftNavLight, rightNavLight, tailNavLight);

    // ------------------ KOKPİT İÇİ ------------------

    cockpitRig = new THREE.Object3D();
    cockpitRig.position.set(2.4, 0.8, 0);
    jet.add(cockpitRig);

    cockpitRig.add(camera);
    camera.position.set(0, 0.05, 0);

    const panelGeo = new THREE.BoxGeometry(2.6, 1.0, 0.15);
    const cockpitPanel = new THREE.Mesh(panelGeo, panelMaterial);
    cockpitPanel.position.set(3.3, -0.1, 0);
    jet.add(cockpitPanel);

    const screenGeo = new THREE.PlaneGeometry(0.6, 0.4);
    const screenMats = [
        new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.8 }),
        new THREE.MeshBasicMaterial({ color: 0x3b82f6, transparent: true, opacity: 0.8 }),
        new THREE.MeshBasicMaterial({ color: 0xfacc15, transparent: true, opacity: 0.8 })
    ];

    function addScreen(x, y, matIdx) {
        const screen = new THREE.Mesh(screenGeo, screenMats[matIdx]);
        screen.position.set(x, y, 0.08);
        cockpitPanel.add(screen);
        cockpitScreens.push(screen);
    }

    addScreen(-0.8, 0.2, 0);
    addScreen(0.0, 0.15, 1);
    addScreen(0.8, 0.2, 2);
    addScreen(-0.4, -0.25, 1);
    addScreen(0.4, -0.25, 0);

    const hudGlassGeo = new THREE.PlaneGeometry(1.8, 0.6);
    const hudGlassMat = new THREE.MeshBasicMaterial({
        color: 0x38bdf8,
        transparent: true,
        opacity: 0.18
    });
    const hudGlass = new THREE.Mesh(hudGlassGeo, hudGlassMat);
    hudGlass.position.set(3.1, 0.5, 0);
    jet.add(hudGlass);

    controlStick = new THREE.Group();

    const stickBaseGeo = new THREE.CylinderGeometry(0.07, 0.1, 0.6, 10);
    const stickBase = new THREE.Mesh(stickBaseGeo, strutMetalMaterial);
    stickBase.rotation.z = Math.PI / 2;
    stickBase.position.set(0, -0.3, 0);
    controlStick.add(stickBase);

    const stickHandleGeo = new THREE.BoxGeometry(0.18, 0.45, 0.18);
    const stickHandle = new THREE.Mesh(stickHandleGeo, panelMaterial);
    stickHandle.position.set(0.25, 0.05, 0);
    controlStick.add(stickHandle);

    controlStick.position.set(2.1, -0.1, 0);
    jet.add(controlStick);

    const sidePanelGeo = new THREE.BoxGeometry(1.2, 0.6, 0.1);
    const sidePanelL = new THREE.Mesh(sidePanelGeo, panelMaterial);
    const sidePanelR = new THREE.Mesh(sidePanelGeo, panelMaterial);
    sidePanelL.position.set(2.8, -0.3, -1.1);
    sidePanelR.position.set(2.8, -0.3, 1.1);
    sidePanelL.rotation.y = THREE.MathUtils.degToRad(15);
    sidePanelR.rotation.y = THREE.MathUtils.degToRad(-15);
    jet.add(sidePanelL, sidePanelR);

    const floorGeo = new THREE.BoxGeometry(2.5, 0.08, 1.6);
    const floor = new THREE.Mesh(floorGeo, panelMaterial);
    floor.position.set(2.0, -0.4, 0);
    jet.add(floor);

    scene.add(jet);

    // -----------------------
    // FİZİK & KONTROLLER
    // -----------------------
    let throttle = 0;
    let speed = 0;
    let yawInput = 0;
    let pitchInput = 0;
    let verticalSpeed = 0;
    let airborne = false;

    let engineOn = false;
    let landingGearExtended = true;
    let terrainAlarmActive = false;

    let crashed = false;
    let crashTimer = 0;

    const maxSpeed = 210;
    const accel = 35;
    const drag = 0.02;
    const gravity = -9.8;
    const liftFactor = 35;
    const takeoffSpeed = 90;

    let viewYawOffset = 0;
    let viewPitchOffset = 0;

    const hudInfo = document.getElementById("hud-info");
    const hudTerrain = document.getElementById("hud-terrain");

    function resetFlight() {
        // Pistin üzerinde kalkışa hazır konum
        jet.position.set(0, 2.4, 650);
        jet.rotation.set(0, -Math.PI / 2, 0);
        speed = 0;
        throttle = 0;
        yawInput = 0;
        pitchInput = 0;
        verticalSpeed = 0;
        engineOn = false;
        airborne = false;
        landingGearExtended = true;
        crashed = false;
        crashTimer = 0;
        viewYawOffset = 0;
        viewPitchOffset = 0;

        hudTerrain.textContent = "TERRAIN";
        hudTerrain.style.opacity = "0";

        [
            noseWheel, mainWheelL, mainWheelR,
            gearStrutN, gearStrutL, gearStrutR
        ].forEach(o => {
            if (!o) return;
            o.scale.set(1, 1, 1);
        });

        [
            flapL, flapR, elevonL, elevonR,
            canardL, canardR, rudderL, rudderR
        ].forEach(o => {
            if (!o) return;
            o.rotation.x = 0;
            o.rotation.y = 0;
            o.rotation.z = 0;
        });
    }

    resetFlight();

    function updateHUD() {
        const alt = Math.max(0, jet.position.y - 2.4);
        const thr = Math.round(throttle * 100);
        const spdKts = Math.round(speed * 1.94384);
        const engTxt = engineOn ? "ENG ON" : "ENG OFF";
        const gearTxt = landingGearExtended || !airborne ? "GEAR DN" : "GEAR UP";
        hudInfo.textContent = `SPD ${spdKts} KT | ALT ${alt.toFixed(0)} m | THR ${thr}% | ${engTxt} | ${gearTxt}`;
    }

    function updateAfterburner(t) {
        const power = engineOn ? throttle : 0;
        const baseOpacity = power * 0.9;
        const flicker = 0.18 * Math.sin(t * 45) * power;
        const o = THREE.MathUtils.clamp(baseOpacity + flicker, 0, 0.95);
        afterburnerMat.opacity = o;

        const color = new THREE.Color().setHSL(
            0.62 - 0.18 * power,
            0.9,
            0.6 + 0.22 * power
        );
        afterburnerMat.color.copy(color);

        const scaleBase = 1.05 + 1.3 * power;
        const scaleFlicker = 0.23 * Math.sin(t * 33) * power;
        const s = scaleBase + scaleFlicker;
        glowL.scale.setScalar(s);
        glowR.scale.setScalar(s);
    }

    function updateNavLights(t) {
        const blink = 0.5 + 0.5 * Math.sin(t * 4.0);
        const blinkFast = 0.5 + 0.5 * Math.sin(t * 9.0);
        leftNavLight.material.opacity = 0.3 + 0.7 * blink;
        rightNavLight.material.opacity = 0.3 + 0.7 * blinkFast;
        tailNavLight.material.opacity = 0.4 + 0.5 * blink;
    }

    function updateLandingGear(dt) {
        const targetVisible = (!airborne) || landingGearExtended;
        const targetScale = targetVisible ? 1.0 : 0.0;
        const lerpFactor = 4.0 * dt;

        function lerpScale(obj) {
            if (!obj) return;
            const current = obj.scale.y;
            const newScaleY = THREE.MathUtils.lerp(current, targetScale, lerpFactor);
            obj.scale.y = newScaleY;
            obj.scale.x = newScaleY;
            obj.scale.z = newScaleY;
        }

        lerpScale(noseWheel);
        lerpScale(mainWheelL);
        lerpScale(mainWheelR);
        lerpScale(gearStrutN);
        lerpScale(gearStrutL);
        lerpScale(gearStrutR);
    }

    function updateControlSurfaces(dt) {
        const flapTarget = THREE.MathUtils.degToRad(pitchInput * -10);
        const elevonTarget = THREE.MathUtils.degToRad(pitchInput * -14);
        const canardTarget = THREE.MathUtils.degToRad(pitchInput * -16);
        const rudderTarget = THREE.MathUtils.degToRad(yawInput * -20);
        const factor = 6 * dt;

        if (flapL && flapR) {
            flapL.rotation.x = THREE.MathUtils.lerp(flapL.rotation.x, flapTarget, factor);
            flapR.rotation.x = THREE.MathUtils.lerp(flapR.rotation.x, flapTarget, factor);
        }
        if (elevonL && elevonR) {
            elevonL.rotation.x = THREE.MathUtils.lerp(elevonL.rotation.x, elevonTarget, factor);
            elevonR.rotation.x = THREE.MathUtils.lerp(elevonR.rotation.x, elevonTarget, factor);
        }
        if (canardL && canardR) {
            canardL.rotation.z = THREE.MathUtils.lerp(canardL.rotation.z, canardTarget, factor);
            canardR.rotation.z = THREE.MathUtils.lerp(canardR.rotation.z, -canardTarget, factor);
        }
        if (rudderL && rudderR) {
            rudderL.rotation.y = THREE.MathUtils.lerp(rudderL.rotation.y, rudderTarget, factor);
            rudderR.rotation.y = THREE.MathUtils.lerp(rudderR.rotation.y, rudderTarget, factor);
        }

        if (controlStick) {
            const targetPitch = THREE.MathUtils.degToRad(pitchInput * -18);
            const targetRoll = THREE.MathUtils.degToRad(yawInput * -22);
            const s = 5 * dt;
            controlStick.rotation.x = THREE.MathUtils.lerp(controlStick.rotation.x, targetPitch, s);
            controlStick.rotation.z = THREE.MathUtils.lerp(controlStick.rotation.z, targetRoll, s);
        }

        if (noseWheel && !airborne) {
            const steerTarget = THREE.MathUtils.degToRad(yawInput * 30);
            const steerFactor = 5 * dt;
            noseWheel.rotation.z = THREE.MathUtils.lerp(noseWheel.rotation.z, steerTarget, steerFactor);
        }
    }

    function updateCockpitScreens(t) {
        cockpitScreens.forEach((screen, idx) => {
            const phase = t * (1.8 + idx * 0.6);
            const glow = 0.6 + 0.4 * Math.sin(phase);
            screen.material.opacity = 0.4 + 0.6 * glow;
        });
    }

    function updateTerrainAlarm(t) {
        const alt = Math.max(0, jet.position.y - 2.4);
        const descendingFast = verticalSpeed < -6;
        const nearGround = alt < 25;
        terrainAlarmActive = airborne && nearGround && descendingFast;

        if (terrainAlarmActive && !crashed) {
            const blink = 0.5 + 0.5 * Math.sin(t * 8.0);
            hudTerrain.style.opacity = (0.3 + 0.7 * blink).toString();
        } else if (!crashed) {
            hudTerrain.style.opacity = "0";
        }
    }

    function detectCrash() {
        const alt = Math.max(0, jet.position.y - 2.4);
        const severeVertical = verticalSpeed < -18;
        the veryFast = speed > 170;
        const crazyPitch = Math.abs(jet.rotation.x) > 0.9;
        const crazyRoll = Math.abs(jet.rotation.z) > 1.2;
        if (alt < 3 && (severeVertical || veryFast || crazyPitch || crazyRoll)) {
            return true;
        }
        return false;
    }

    function updateCrash(dt, t) {
        crashTimer += dt;
        engineOn = false;
        throttle = Math.max(0, throttle - 0.5 * dt);

        speed *= 0.94;
        jet.position.y = 2.2;

        const slideDir = new THREE.Vector3(0, 0, 1);
        slideDir.applyQuaternion(jet.quaternion);
        jet.position.addScaledVector(slideDir, speed * 0.4 * dt);

        jet.rotation.x = THREE.MathUtils.lerp(jet.rotation.x, 0.6, 1.5 * dt);
        jet.rotation.z += 1.2 * dt;

        hudTerrain.textContent = "CRASH";
        const blink = 0.5 + 0.5 * Math.sin(t * 10);
        hudTerrain.style.opacity = (0.4 + 0.6 * blink).toString();

        updateCockpitScreens(t);
        updateNavLights(t);
        updateAfterburner(t);
        updateHUD();

        if (crashTimer > 3.0) {
            resetFlight();
        }
    }

    function updateJetPhysics(dt, t) {
        if (crashed) {
            updateCrash(dt, t);
            return;
        }

        if (!engineOn) {
            throttle = Math.max(0, throttle - 0.4 * dt);
        }

        const targetSpeed = (engineOn ? throttle : 0) * maxSpeed;
        const diff = targetSpeed - speed;
        speed += diff * Math.min(1, accel * dt);
        speed *= (1 - drag * dt);
        if (speed < 0.01) speed = 0;

        const yawRate = 0.7;
        jet.rotation.y += yawInput * yawRate * dt;

        const pitchRate = 0.45;
        jet.rotation.x += pitchInput * pitchRate * dt;
        jet.rotation.x = THREE.MathUtils.clamp(jet.rotation.x, -0.6, 0.4);

        const rollTarget = yawInput * THREE.MathUtils.degToRad(-20);
        const rollAutoPitch = pitchInput * THREE.MathUtils.degToRad(5);
        const rollCurrent = jet.rotation.z;
        const rollDiff = (rollTarget + rollAutoPitch) - rollCurrent;
        jet.rotation.z += rollDiff * 2.4 * dt;

        const forwardLocal = new THREE.Vector3(1, 0, 0);
        forwardLocal.applyQuaternion(jet.quaternion);
        jet.position.addScaledVector(forwardLocal, speed * dt);

        if (!airborne) {
            jet.position.y = 2.4;
            verticalSpeed = 0;

            if (speed > takeoffSpeed && pitchInput < -0.15) {
                airborne = true;
                verticalSpeed = 11;
            }
        } else {
            const angleOfAttack = -jet.rotation.x;
            const lift = Math.max(0, angleOfAttack * liftFactor);
            verticalSpeed += (gravity + lift) * dt;
            jet.position.y += verticalSpeed * dt;

            const groundLevel = 2.4;
            if (jet.position.y <= groundLevel) {
                jet.position.y = groundLevel;
                if (detectCrash()) {
                    crashed = true;
                    crashTimer = 0;
                    return;
                }
                if (verticalSpeed < -20) {
                    verticalSpeed = 7;
                } else {
                    verticalSpeed = 0;
                    if (speed < 70 && Math.abs(angleOfAttack) < 0.2) {
                        airborne = false;
                        landingGearExtended = true;
                    }
                }
            } else if (detectCrash()) {
                crashed = true;
                crashTimer = 0;
                return;
            }
        }

        if (cockpitRig) {
            const cockpitWorld = new THREE.Vector3();
            cockpitRig.getWorldPosition(cockpitWorld);

            const viewDirLocal = new THREE.Vector3(1, 0, 0);
            const viewEuler = new THREE.Euler(viewPitchOffset, viewYawOffset, 0, "YXZ");
            viewDirLocal.applyEuler(viewEuler);
            const viewDirWorld = viewDirLocal.clone().applyQuaternion(jet.quaternion);
            const lookTarget = cockpitWorld.clone().add(viewDirWorld.multiplyScalar(200));

            camera.position.set(0, 0.05, 0);
            camera.lookAt(lookTarget);
        }

        const wingOsc = Math.sin(t * 6) * 0.02 * throttle;
        if (leftWing && rightWing && tail) {
            leftWing.rotation.x = THREE.MathUtils.degToRad(3) + wingOsc;
            rightWing.rotation.x = THREE.MathUtils.degToRad(-3) - wingOsc;
            tail.rotation.y = yawInput * THREE.MathUtils.degToRad(8);
        }

        updateControlSurfaces(dt);
        updateLandingGear(dt);
        updateAfterburner(t);
        updateNavLights(t);
        updateTerrainAlarm(t);
        updateCockpitScreens(t);
        updateHUD();
    }

    function updateClouds(dt) {
        clouds.forEach(c => {
            c.position.x += 2 * dt;
            c.position.z += 1 * dt;
            const r = Math.sqrt(c.position.x * c.position.x + c.position.z * c.position.z);
            if (r > 2200) {
                const angle = Math.random() * Math.PI * 2;
                const radius = THREE.MathUtils.randFloat(600, 1800);
                c.position.set(
                    Math.cos(angle) * radius,
                    THREE.MathUtils.randFloat(160, 260),
                    Math.sin(angle) * radius
                );
            }
        });
    }

    function bindButton(selector, onPress, onRelease) {
        const el = document.querySelector(selector);
        if (!el) return;

        const start = (ev) => {
            ev.preventDefault();
            onPress();
        };
        const end = (ev) => {
            ev.preventDefault();
            onRelease();
        };

        el.addEventListener('touchstart', start, { passive: false });
        el.addEventListener('touchend', end, { passive: false });
        el.addEventListener('touchcancel', end, { passive: false });

        el.addEventListener('mousedown', start);
        window.addEventListener('mouseup', end);
    }

    bindButton('.btn-thr-up',
        () => { if (engineOn && !crashed) throttle = Math.min(1, throttle + 0.02); },
        () => {}
    );
    bindButton('.btn-thr-down',
        () => { if (engineOn && !crashed) throttle = Math.max(0, throttle - 0.02); },
        () => {}
    );

    bindButton('.btn-pitch-up',
        () => { if (!crashed) pitchInput = -1; },
        () => { pitchInput = 0; }
    );
    bindButton('.btn-pitch-down',
        () => { if (!crashed) pitchInput = 1; },
        () => { pitchInput = 0; }
    );

    bindButton('.btn-yaw-left',
        () => { if (!crashed) yawInput = -1; },
        () => { yawInput = 0; }
    );
    bindButton('.btn-yaw-right',
        () => { if (!crashed) yawInput = 1; },
        () => { yawInput = 0; }
    );

    bindButton('.btn-eng-on',
        () => {
            if (!crashed) {
                engineOn = true;
                if (throttle < 0.2) throttle = 0.2;
            }
        },
        () => {}
    );
    bindButton('.btn-eng-off',
        () => {
            engineOn = false;
        },
        () => {}
    );

    bindButton('.btn-gear',
        () => {
            if (!crashed) {
                if (airborne) {
                    landingGearExtended = !landingGearExtended;
                } else {
                    landingGearExtended = true;
                }
            }
        },
        () => {}
    );

    // Kokpitten etrafa bakma (ekrana dokunup sürükle)
    let looking = false;
    let lastLookX = 0;
    let lastLookY = 0;

    const maxViewYaw = 0.7;
    const maxViewPitch = 0.4;

    function onPointerDown(e) {
        if (e.pointerType === "mouse" && e.button !== 0) return;
        if (crashed) return;
        if (e.target !== canvas) return;
        looking = true;
        lastLookX = e.clientX;
        lastLookY = e.clientY;
    }

    function onPointerMove(e) {
        if (!looking) return;
        const dx = e.clientX - lastLookX;
        const dy = e.clientY - lastLookY;
        lastLookX = e.clientX;
        lastLookY = e.clientY;

        viewYawOffset += dx * 0.003;
        viewPitchOffset += -dy * 0.002;

        viewYawOffset = THREE.MathUtils.clamp(viewYawOffset, -maxViewYaw, maxViewYaw);
        viewPitchOffset = THREE.MathUtils.clamp(viewPitchOffset, -maxViewPitch, maxViewPitch);
    }

    function onPointerUp() {
        looking = false;
    }

    canvas.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);
    window.addEventListener('pointercancel', onPointerUp);

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const t = clock.elapsedTime;

        updateJetPhysics(dt, t);
        updateClouds(dt);

        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        const w = container.clientWidth;
        const h = container.clientHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
    });

    // ---------------------------------------------------------------------
    // KISA KULLANIM NOTLARI (yorum satırları)
    //  - ENG ON: Motoru çalıştırır, throttle en az %20'ye çıkar.
    //  - ENG OFF: Motoru kapatır, throttle yavaşça düşer.
    //  - THR +/-: Gazı %0 - %100 arası arttır / azalt.
    //  - NOSE UP / DOWN: Pitch kontrolü (burun kaldır / indir).
    //  - YAW ◀ / ▶: Yaw kontrolü (sağa / sola dön).
    //  - GEAR: Havadayken iniş takımlarını aç / kapat.
    //  - Ekrana dokunup sürükleyerek kokpitten sağa/sola/yukarı/aşağı bak.
    //  - Sert iniş / çakılma durumunda CRASH olur, birkaç saniye sonra pistten
    //    yeniden kalkışa hazır başlarsın.
    // ---------------------------------------------------------------------
})();
</script>
</body>
</html>
