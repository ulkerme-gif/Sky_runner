<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8" />
    <title>SkyRunner 3D - Mini Flight Sim (Tablet)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* HUD */
        .hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .hud-top-left {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            font-size: 11px;
            max-width: 260px;
            backdrop-filter: blur(6px);
        }

        .hud-top-left h1 {
            font-size: 14px;
            margin-bottom: 4px;
        }

        .hud-top-left p {
            opacity: 0.9;
            line-height: 1.4;
        }

        .hud-top-center {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            font-size: 11px;
            backdrop-filter: blur(6px);
        }

        .hud-chip {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .hud-label {
            font-size: 10px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .hud-value {
            font-size: 13px;
            font-weight: 600;
        }

        .hud-top-right {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 6px 10px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            font-size: 11px;
            backdrop-filter: blur(6px);
        }

        .hud-top-right div {
            margin-bottom: 2px;
        }

        .hud-bottom-center {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.4);
            color: #fff;
            font-size: 11px;
            backdrop-filter: blur(6px);
        }

        /* Dokunmatik kontroller */
        .touch-controls {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .pad-left,
        .pad-right {
            position: absolute;
            bottom: 12px;
            width: 46%;
            max-width: 280px;
            height: 42%;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 10px;
            pointer-events: auto;
        }

        .pad-left {
            left: 6px;
        }

        .pad-right {
            right: 6px;
        }

        .ctrl-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .ctrl-row {
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        .ctrl-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: none;
            background: radial-gradient(circle at 30% 30%, #ffffff, #bfc3c7);
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.6);
            font-size: 22px;
            font-weight: 700;
            color: #333;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        .ctrl-btn.small {
            width: 52px;
            height: 52px;
            font-size: 18px;
        }

        .ctrl-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 rgba(0, 0, 0, 0.7);
        }

        .ctrl-label {
            text-align: center;
            color: #fff;
            font-size: 11px;
            margin-top: 2px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.9);
        }

        /* Reticle */
        .reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid rgba(0, 255, 0, 0.85);
            box-shadow: 0 0 10px rgba(0,255,0,0.8);
            pointer-events: none;
        }

        .reticle::before,
        .reticle::after {
            content: "";
            position: absolute;
            background: rgba(0,255,0,0.7);
        }

        .reticle::before {
            width: 130%;
            height: 1px;
            top: 50%;
            left: -15%;
        }

        .reticle::after {
            width: 1px;
            height: 130%;
            left: 50%;
            top: -15%;
        }

        .center-message {
            position: absolute;
            top: 22%;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 16px;
            border-radius: 14px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            text-align: center;
            font-size: 12px;
            max-width: 320px;
            pointer-events: none;
            backdrop-filter: blur(6px);
        }

        .center-message-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .center-message-sub {
            opacity: 0.9;
        }

        .fade-out {
            animation: fadeOut 0.7s forwards;
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to   { opacity: 0; visibility: hidden; }
        }

        .game-over-banner {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 16px;
            border-radius: 10px;
            background: rgba(120, 0, 0, 0.88);
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            pointer-events: none;
            display: none;
        }

        .game-over-banner span {
            display: block;
            font-size: 11px;
            font-weight: 400;
            margin-top: 4px;
            opacity: 0.9;
        }

        @media (max-width: 768px) {
            .hud-top-left { font-size: 11px; max-width: 230px; }
            .hud-top-center { font-size: 11px; }
            .hud-value { font-size: 13px; }
        }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="hud">
        <div class="hud-top-left">
            <h1>SkyRunner 3D</h1>
            <p>
                Tablet: Soldaki pad <strong>yaw / roll</strong>, sağdaki pad <strong>pitch</strong> ve <strong>gaz</strong>.<br/>
                Klavye (PC): W/S (gaz), A/D (yaw+roll), ok tuşları (pitch).<br/>
                R: Reset · Sert inişte CRASH.
            </p>
        </div>

        <div class="hud-top-center">
            <div class="hud-chip">
                <div class="hud-label">Hız (kn)</div>
                <div class="hud-value" id="hudSpeed">0</div>
            </div>
            <div class="hud-chip">
                <div class="hud-label">Yükseklik (m)</div>
                <div class="hud-value" id="hudAlt">0</div>
            </div>
            <div class="hud-chip">
                <div class="hud-label">Mesafe (km)</div>
                <div class="hud-value" id="hudDist">0.0</div>
            </div>
            <div class="hud-chip">
                <div class="hud-label">Durum</div>
                <div class="hud-value" id="hudStatus">IDLE</div>
            </div>
        </div>

        <div class="hud-top-right">
            <div>FPS: <span id="hudFps">0</span></div>
            <div>Stall: <span id="hudStall">Yok</span></div>
        </div>

        <div class="hud-bottom-center">
            Mini flight sim: yerçekimi, lift, stall, basit aerodinamik ve tablet dostu kontroller.
        </div>

        <div class="reticle"></div>

        <div class="center-message" id="startMessage">
            <div class="center-message-title">Uçuşa Hazır ✈️</div>
            <div class="center-message-sub">
                Gaz vermek için sağ alttaki <b>+</b> tuşuna dokun veya klavyeden <b>W</b> / <b>↑</b>'a bas.
            </div>
        </div>

        <div class="game-over-banner" id="gameOverBanner">
            CRASH! Uçak yere çok sert indi.
            <span>R tuşuna basarak veya sayfayı yenileyerek yeniden başlayabilirsin.</span>
        </div>
    </div>

    <!-- Dokunmatik kontrol padleri -->
    <div class="touch-controls">
        <!-- Sol pad: yaw + roll -->
        <div class="pad-left">
            <div class="ctrl-group">
                <div class="ctrl-row">
                    <button class="ctrl-btn" id="btnYawLeft">◀</button>
                    <button class="ctrl-btn" id="btnYawRight">▶</button>
                </div>
                <div class="ctrl-label">Yön / Roll</div>
            </div>
        </div>

        <!-- Sağ pad: pitch ve throttle -->
        <div class="pad-right">
            <div class="ctrl-group">
                <div class="ctrl-row">
                    <button class="ctrl-btn small" id="btnThrottleDown">–</button>
                    <button class="ctrl-btn small" id="btnThrottleUp">+</button>
                </div>
                <div class="ctrl-label">Gaz</div>
                <div class="ctrl-row">
                    <button class="ctrl-btn" id="btnPitchUp">▲</button>
                    <button class="ctrl-btn" id="btnPitchDown">▼</button>
                </div>
                <div class="ctrl-label">Pitch / İrtifa</div>
            </div>
        </div>
    </div>
</div>

<!-- three.js CDN -->
<script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>

<script>
(function () {
    "use strict";

    const canvas = document.getElementById("gameCanvas");
    const hudSpeed = document.getElementById("hudSpeed");
    const hudAlt   = document.getElementById("hudAlt");
    const hudDist  = document.getElementById("hudDist");
    const hudStatus= document.getElementById("hudStatus");
    const hudFps   = document.getElementById("hudFps");
    const hudStall = document.getElementById("hudStall");
    const startMessage = document.getElementById("startMessage");
    const gameOverBanner = document.getElementById("gameOverBanner");

    const btnYawLeft       = document.getElementById("btnYawLeft");
    const btnYawRight      = document.getElementById("btnYawRight");
    const btnPitchUp       = document.getElementById("btnPitchUp");
    const btnPitchDown     = document.getElementById("btnPitchDown");
    const btnThrottleUp    = document.getElementById("btnThrottleUp");
    const btnThrottleDown  = document.getElementById("btnThrottleDown");

    function resize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        if (camera) {
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height, false);
        }
    }
    window.addEventListener("resize", resize);

    // THREE Setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x88aaff, 100, 2800);

    const camera = new THREE.PerspectiveCamera(
        65,
        window.innerWidth / window.innerHeight,
        0.1,
        6000
    );

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    renderer.outputEncoding = THREE.sRGBEncoding;

    // Lights
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x406080, 0.95);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(80, 180, -60);
    scene.add(dirLight);

    // Sky
    const skyGeo = new THREE.SphereGeometry(4000, 24, 16);
    const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
            topColor: { value: new THREE.Color(0x4da0ff) },
            bottomColor: { value: new THREE.Color(0x02101e) },
            offset: { value: 400 },
            exponent: { value: 0.6 },
            time: { value: 0.0 }
        },
        vertexShader: `
            varying float vHeight;
            void main() {
                vHeight = position.y;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            varying float vHeight;

            void main() {
                float h = normalize(vec3(0.0, vHeight + offset, 0.0)).y;
                float t = max(pow(max(h, 0.0), exponent), 0.0);
                gl_FragColor = vec4(mix(bottomColor, topColor, t), 1.0);
            }
        `
    });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // Ground (daha basit segment, performans için)
    const groundGeo = new THREE.PlaneGeometry(8000, 8000, 32, 32);
    const groundMat = new THREE.MeshStandardMaterial({
        color: 0x113322,
        roughness: 0.95,
        metalness: 0.0,
        vertexColors: true
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    // Basit renk gürültüsü
    const pos = groundGeo.attributes.position;
    const colors = [];
    for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const z = pos.getZ(i);
        const dist = Math.sqrt(x*x + z*z);
        const factor = 0.2 + 0.2 * Math.random() + 0.2 * Math.max(0, 1 - dist / 4000);
        colors.push(0.06, factor, 0.06);
    }
    groundGeo.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));

    // Runway
    const runwayGeo = new THREE.PlaneGeometry(600, 40);
    const runwayMat = new THREE.MeshStandardMaterial({
        color: 0x333333,
        roughness: 0.8
    });
    const runway = new THREE.Mesh(runwayGeo, runwayMat);
    runway.rotation.x = -Math.PI / 2;
    runway.position.set(0, 0.02, -300);
    scene.add(runway);

    const stripeGeo = new THREE.PlaneGeometry(30, 3);
    const stripeMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    for (let i = 0; i < 10; i++) {
        const stripe = new THREE.Mesh(stripeGeo, stripeMat);
        stripe.rotation.x = -Math.PI / 2;
        stripe.position.set(0, 0.03, -300 + i * 50);
        scene.add(stripe);
    }

    // City
    const cityGroup = new THREE.Group();
    const buildingGeo = new THREE.BoxGeometry(20, 40, 20);
    for (let i = 0; i < 45; i++) {
        const mat = new THREE.MeshStandardMaterial({
            color: new THREE.Color().setHSL(0.55 + Math.random() * 0.05, 0.35, 0.25 + Math.random() * 0.15),
            roughness: 0.85
        });
        const b = new THREE.Mesh(buildingGeo, mat);
        b.scale.y = 1 + Math.random() * 4;
        const side = Math.random() < 0.5 ? -1 : 1;
        const dist = 300 + Math.random() * 2500;
        const offsetX = side * (110 + Math.random() * 450);
        const offsetZ = dist + (Math.random() - 0.5) * 500;
        b.position.set(offsetX, (b.scale.y * 40) / 2, offsetZ);
        cityGroup.add(b);
    }
    scene.add(cityGroup);

    // Clouds (hafif)
    const cloudGroup = new THREE.Group();
    scene.add(cloudGroup);

    function createCloud(x, y, z) {
        const cloud = new THREE.Group();
        const sphereGeo = new THREE.SphereGeometry(20, 12, 10);
        const mat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
        for (let i = 0; i < 4; i++) {
            const s = new THREE.Mesh(sphereGeo, mat);
            s.position.set(
                (Math.random() - 0.5) * 45,
                (Math.random() - 0.5) * 12,
                (Math.random() - 0.5) * 45
            );
            const scale = 0.7 + Math.random() * 0.8;
            s.scale.set(scale, scale, scale);
            cloud.add(s);
        }
        cloud.position.set(x, y, z);
        cloudGroup.add(cloud);
    }

    for (let i = 0; i < 22; i++) {
        const cx = (Math.random() - 0.5) * 1000;
        const cz = 200 + Math.random() * 2800;
        const cy = 80 + Math.random() * 140;
        createCloud(cx, cy, cz);
    }

    // Plane
    const plane = new THREE.Group();
    const bodyGeo = new THREE.CylinderGeometry(1.2, 1.2, 18, 12);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xf5f6fa, metalness: 0.35, roughness: 0.4 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.rotation.z = Math.PI / 2;
    plane.add(body);

    const noseGeo = new THREE.ConeGeometry(1.5, 3.5, 12);
    const noseMat = new THREE.MeshStandardMaterial({ color: 0x3498db, metalness: 0.5, roughness: 0.25 });
    const nose = new THREE.Mesh(noseGeo, noseMat);
    nose.position.set(9, 0, 0);
    nose.rotation.z = Math.PI / 2;
    plane.add(nose);

    const wingGeo = new THREE.BoxGeometry(1, 16, 0.4);
    const wingMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6, roughness: 0.5 });
    const wingLeft = new THREE.Mesh(wingGeo, wingMat);
    wingLeft.position.set(0, 0, -6);
    plane.add(wingLeft);
    const wingRight = wingLeft.clone();
    wingRight.position.z = 6;
    plane.add(wingRight);

    const tailGeo = new THREE.BoxGeometry(1.2, 4, 0.2);
    const tail = new THREE.Mesh(tailGeo, wingMat);
    tail.position.set(-8, 2, 0);
    tail.rotation.z = Math.PI / 10;
    plane.add(tail);

    const tailHGeo = new THREE.BoxGeometry(0.8, 4, 0.2);
    const tailHLeft = new THREE.Mesh(tailHGeo, wingMat);
    tailHLeft.position.set(-7, 0, -2.5);
    plane.add(tailHLeft);
    const tailHRight = tailHLeft.clone();
    tailHRight.position.z = 2.5;
    plane.add(tailHRight);

    plane.position.set(0, 5, 0);
    plane.rotation.set(0, 0, 0);
    scene.add(plane);

    camera.position.set(-15, 8, 25);
    camera.lookAt(plane.position);

    // INPUT
    const keys = {};
    const input = {
        yawLeft: false,
        yawRight: false,
        pitchUp: false,
        pitchDown: false,
        throttleUp: false,
        throttleDown: false
    };

    window.addEventListener("keydown", e => {
        keys[e.key] = true;
        if (e.key === "w" || e.key === "ArrowUp") input.throttleUp = true;
        if (e.key === "s" || e.key === "ArrowDown") input.throttleDown = true;
        if (e.key === "a" || e.key === "ArrowLeft") input.yawLeft = true;
        if (e.key === "d" || e.key === "ArrowRight") input.yawRight = true;
        if (e.key === "r" || e.key === "R") resetGame();
    });

    window.addEventListener("keyup", e => {
        keys[e.key] = false;
        if (e.key === "w" || e.key === "ArrowUp") input.throttleUp = false;
        if (e.key === "s" || e.key === "ArrowDown") input.throttleDown = false;
        if (e.key === "a" || e.key === "ArrowLeft") input.yawLeft = false;
        if (e.key === "d" || e.key === "ArrowRight") input.yawRight = false;
    });

    function bindTouchButton(btn, prop) {
        const on = (ev) => { ev.preventDefault(); input[prop] = true; };
        const off= (ev) => { ev.preventDefault(); input[prop] = false; };
        ["touchstart","mousedown"].forEach(ev => btn.addEventListener(ev, on));
        ["touchend","touchcancel","mouseup","mouseleave"].forEach(ev => btn.addEventListener(ev, off));
    }

    bindTouchButton(btnYawLeft,      "yawLeft");
    bindTouchButton(btnYawRight,     "yawRight");
    bindTouchButton(btnPitchUp,      "pitchUp");
    bindTouchButton(btnPitchDown,    "pitchDown");
    bindTouchButton(btnThrottleUp,   "throttleUp");
    bindTouchButton(btnThrottleDown, "throttleDown");

    // FLIGHT STATE
    let throttle = 0;             // 0..1
    let speed = 0;                // m/s
    const maxSpeed = 120;         // m/s (~233kn)
    let distanceTravelled = 0;
    let gameOver = false;
    let hasStarted = false;

    let lastAlt = plane.position.y;
    let isStalling = false;

    const gravity = 9.81;
    const stallSpeed = 35;        // m/s
    const liftCoeff = 2.4;
    const dragCoeff = 0.025;

    const clock = new THREE.Clock();

    let fpsAccum = 0;
    let fpsFrames = 0;
    let fpsDisplay = 0;
    let fpsTimer = 0;

    function resetGame() {
        throttle = 0;
        speed = 0;
        distanceTravelled = 0;
        gameOver = false;
        hasStarted = false;
        isStalling = false;
        plane.position.set(0, 5, 0);
        plane.rotation.set(0, 0, 0);
        camera.position.set(-15, 8, 25);
        camera.lookAt(plane.position);
        hudStatus.textContent = "IDLE";
        hudSpeed.textContent = "0";
        hudAlt.textContent = "5";
        hudDist.textContent = "0.0";
        hudStall.textContent = "Yok";
        gameOverBanner.style.display = "none";
        if (startMessage) {
            startMessage.classList.remove("fade-out");
            startMessage.style.opacity = "1";
        }
        clock.getDelta();
    }

    resetGame();
    resize();

    function updateFlight(dt) {
        if (gameOver) return;

        dt = Math.min(dt, 0.04); // FPS dalgalanmasında saçma zıplamayı engelle

        const throttleChange = 0.45 * dt;
        if (input.throttleUp) {
            throttle += throttleChange;
            hasStarted = true;
        }
        if (input.throttleDown) {
            throttle -= throttleChange;
        }
        throttle = THREE.MathUtils.clamp(throttle, 0, 1);

        const targetSpeed = maxSpeed * throttle;
        const accelToTarget = (targetSpeed - speed) * (0.75 * dt);
        speed += accelToTarget;
        if (speed < 0.1) speed = 0;

        const yawRate   = THREE.MathUtils.degToRad(38);
        const pitchRate = THREE.MathUtils.degToRad(24);
        const rollRate  = THREE.MathUtils.degToRad(33);

        if (speed > 5) {
            if (input.yawLeft && !input.yawRight) {
                plane.rotation.y += yawRate * dt;
                plane.rotation.z += rollRate * dt * 0.55;
            } else if (input.yawRight && !input.yawLeft) {
                plane.rotation.y -= yawRate * dt;
                plane.rotation.z -= rollRate * dt * 0.55;
            } else {
                plane.rotation.z *= (1 - 1.8 * dt);
            }

            if (input.pitchUp && !input.pitchDown) {
                plane.rotation.x -= pitchRate * dt;
            } else if (input.pitchDown && !input.pitchUp) {
                plane.rotation.x += pitchRate * dt;
            } else {
                plane.rotation.x *= (1 - 1.2 * dt);
            }
        } else {
            plane.rotation.z *= (1 - 2.0 * dt);
            plane.rotation.x *= (1 - 1.5 * dt);
        }

        plane.rotation.x = THREE.MathUtils.clamp(plane.rotation.x, -0.6, 0.55);
        plane.rotation.z = THREE.MathUtils.clamp(plane.rotation.z, -0.9, 0.9);

        const forward = new THREE.Vector3(0,0,-1).applyEuler(plane.rotation).normalize();

        // Basitleştirilmiş aerodinamik
        const speedSq = speed * speed;

        const drag = dragCoeff * speedSq;
        const dragVec = forward.clone().multiplyScalar(-drag);

        let lift = 0;
        if (speed > stallSpeed) {
            const aoa = -plane.rotation.x;
            lift = liftCoeff * speedSq * Math.max(0, Math.cos(aoa));
        } else {
            lift = -20; // stall durumunda uçağı aşağı çeken ek kuvvet
        }

        const liftVec = new THREE.Vector3(0, lift, 0);
        const gravityVec = new THREE.Vector3(0, -gravity * 18, 0);

        const thrust = throttle * 150;
        const thrustVec = forward.clone().multiplyScalar(thrust);

        const accel = new THREE.Vector3();
        accel.add(thrustVec);
        accel.add(dragVec);
        accel.add(liftVec);
        accel.add(gravityVec);

        // Hızı vektörel taşı
        let velForward = forward.clone().multiplyScalar(speed);
        velForward.add(accel.multiplyScalar(dt));

        // Yeni hız büyüklüğü
        const newSpeed = velForward.length();
        speed = THREE.MathUtils.clamp(newSpeed, 0, maxSpeed);

        // Tekrar forward yönüne projeksiyon (stabilite için)
        if (speed > 0.001) {
            velForward.normalize().multiplyScalar(speed);
        } else {
            velForward.set(0,0,0);
        }

        const move = velForward.clone().multiplyScalar(dt);
        plane.position.add(move);
        distanceTravelled += move.length();

        const groundHeight = 0;
        const altitude = plane.position.y - groundHeight;
        const verticalSpeed = (plane.position.y - lastAlt) / dt;
        lastAlt = plane.position.y;

        if (plane.position.y < groundHeight + 1.5) {
            plane.position.y = groundHeight + 1.5;
            if (Math.abs(verticalSpeed) > 10 || speed > 22) {
                triggerGameOver();
            } else {
                // yumuşak iniş
                speed *= 0.8;
            }
        }

        if (plane.position.y > 900) {
            plane.position.y = 900;
        }

        // Kamera: daha stabil, yumuşak takip
        const camOffset = new THREE.Vector3(0, 8, 26);
        camOffset.applyEuler(plane.rotation);
        const desiredCamPos = plane.position.clone().add(camOffset);
        camera.position.lerp(desiredCamPos, 0.12);
        const lookAtPoint = plane.position.clone().add(forward.clone().multiplyScalar(45));
        camera.lookAt(lookAtPoint);

        // Bulut kaydırma (yalnızca z yönünde hafif animasyon)
        cloudGroup.children.forEach(cloud => {
            cloud.position.z -= 12 * dt;
            if (cloud.position.z < -800) {
                cloud.position.z = 2800 + Math.random() * 600;
                cloud.position.x = (Math.random() - 0.5) * 1000;
                cloud.position.y = 80 + Math.random() * 150;
            }
        });

        const speedKnots = speed * 1.94384;
        hudSpeed.textContent = speedKnots.toFixed(0);
        hudAlt.textContent = altitude.toFixed(0);
        hudDist.textContent = (distanceTravelled / 1000).toFixed(1);

        // Status & stall
        if (!hasStarted && speed < 2) {
            hudStatus.textContent = "IDLE";
        } else if (speed < stallSpeed) {
            hudStatus.textContent = "STALL/OFF";
        } else if (speed < stallSpeed + 15) {
            hudStatus.textContent = "ROTATE";
        } else if (speed < 80) {
            hudStatus.textContent = "CLIMB";
        } else {
            hudStatus.textContent = "CRUISE";
        }

        isStalling = speed < stallSpeed && altitude > 5 && throttle < 0.7;
        hudStall.textContent = isStalling ? "Evet" : "Yok";

        if (hasStarted && startMessage && startMessage.style.opacity !== "0") {
            startMessage.classList.add("fade-out");
        }
    }

    function triggerGameOver() {
        if (gameOver) return;
        gameOver = true;
        hudStatus.textContent = "CRASH";
        gameOverBanner.style.display = "block";
    }

    function renderLoop() {
        const dt = clock.getDelta();
        updateFlight(dt);

        const fps = 1 / Math.max(dt, 0.00001);
        fpsAccum += fps;
        fpsFrames++;
        fpsTimer += dt;
        if (fpsTimer >= 0.5) {
            fpsDisplay = fpsAccum / fpsFrames;
            fpsAccum = 0;
            fpsFrames = 0;
            fpsTimer = 0;
            hudFps.textContent = fpsDisplay.toFixed(0);
        }

        renderer.render(scene, camera);
        requestAnimationFrame(renderLoop);
    }

    renderLoop();
})();
</script>
</body>
</html>
